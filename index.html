<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wine-Dark Character Sheet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        :root {
            --default-section-bg: #580b20; /* Default header background color */
            --grid-gap: 1rem; /* Reduced gap for tighter layout */
            --grid-columns: 12;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            color: #333;
            padding: 1rem;
        }
        .character-sheet {
            max-width: 1000px;
            margin: auto;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: var(--grid-gap);
            display: grid;
            grid-template-columns: repeat(var(--grid-columns), 1fr);
            gap: var(--grid-gap);
            position: relative; /* Needed for absolute positioning context */
        }

        /* --- Sheet Actions Container (Top Right) --- */
        #sheet-actions-container {
            position: absolute;
            top: calc(var(--grid-gap) * 0.5); /* Adjust as needed */
            right: calc(var(--grid-gap) * 0.5); /* Adjust as needed */
            z-index: 10; /* Ensure it's above section headers */
            display: flex;
            gap: 0.5rem;
            background-color: rgba(255, 255, 255, 0.8); /* Slight background */
            padding: 0.5rem;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        /* Style buttons within the sheet actions container */
        #sheet-actions-container .action-btn {
             background-color: #6b7280; /* Gray background */
             color: white;
             border: 1px solid #4b5563;
             padding: 0.3rem 0.6rem; /* Adjust padding */
             font-size: 0.9rem;
        }
         #sheet-actions-container .action-btn:hover {
             background-color: #4b5563; /* Darker gray on hover */
         }
         #sheet-actions-container .new-char-btn {
             background-color: #ef4444; /* Red background */
             border-color: #dc2626;
         }
         #sheet-actions-container .new-char-btn:hover {
             background-color: #dc2626; /* Darker red on hover */
         }


        /* --- Section Styling --- */
        .styled-section {
            margin-bottom: 0; /* Grid gap handles spacing */
            border-radius: 6px;
            overflow: hidden; /* Ensures content stays within rounded borders */
            border: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            min-height: 150px; /* Minimum height for sections */
            position: relative; /* For absolute positioned elements inside */
            background-color: #f9f9f9; /* Light background for section content area */
            resize: none; /* Prevent user resizing */
        }
        .section-header {
            background-color: var(--default-section-bg);
            color: white;
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 40px; /* Ensure header has consistent height */
            user-select: none; /* Prevent text selection in header */
            cursor: default; /* Default cursor for header */
        }
        .section-title-container { display: flex; align-items: center; gap: 0.5rem; flex-grow: 1; cursor: default; }
        .section-title-text { font-weight: bold; font-size: 1.1rem; }
        /* Smaller title for dynamic inventory */
        .dynamic-inventory-section .section-title-text { font-size: 1rem; }
        .section-title-input {
            font-weight: bold; font-size: 1.1rem; border: none;
            background-color: rgba(255, 255, 255, 0.2); color: white;
            padding: 0.2rem 0.4rem; border-radius: 3px; outline: none;
            display: none; /* Hidden by default */
            width: auto; min-width: 150px;
        }
        .dynamic-inventory-section .section-title-input { font-size: 1rem; }
         /* Toggle visibility when editing title */
         .section-title-container.editing .section-title-text,
         .section-title-container.editing .edit-title-btn { display: none; }
         .section-title-container.editing .section-title-input { display: inline-block; }

        .section-actions { display: flex; align-items: center; gap: 0.5rem; position: relative; }
        .section-content { padding: 1rem; border-top: none; flex-grow: 1; overflow-y: auto; }
        .section-footer { padding: 0.5rem 1rem; text-align: center; border-top: 1px solid #eee; }

        /* Action Buttons Styling (for section headers) */
        .action-btn { /* Buttons in header */
            background: none; border: 1px solid rgba(255, 255, 255, 0.5); color: white;
            cursor: pointer; font-size: 1rem; line-height: 1; padding: 0.25rem 0.4rem; /* Default padding */
            border-radius: 4px; transition: background-color 0.2s, color 0.2s; font-weight: bold;
            display: inline-flex; /* Ensure flex alignment works */
            align-items: center;
            justify-content: center;
        }
        .action-btn:hover { background-color: rgba(255, 255, 255, 0.2); }
         .edit-title-btn { font-size: 0.9rem; padding: 0.1rem 0.3rem; } /* Smaller padding for edit */
         .delete-mode-btn {
             font-size: 1rem;
             padding: 0.4rem 0.6rem; /* Increased padding */
         }
         .delete-mode-btn.active { background-color: rgba(255, 80, 80, 0.3); border-color: rgba(255, 80, 80, 0.7); }

         /* Color Picker Positioning */
         .color-picker-btn { /* Class added to the color button's wrapper */
             position: relative; /* Make it a positioning context */
             display: inline-flex; /* Align icon properly */
             align-items: center;
             justify-content: center;
         }
         .color-picker-input {
             opacity: 0; /* Hidden visually */
             width: 100%; height: 100%; /* Cover the button */
             position: absolute;
             left: 0; /* Align with button */
             top: 0;  /* Align with button */
             cursor: pointer; border: none; padding: 0;
             z-index: 1; /* Ensure it's clickable on top */
         }

         .add-entry-footer-btn { /* Green '+' button below content */
            background-color: #10b981; color: white; border: none; border-radius: 50%;
            width: 28px; height: 28px; font-size: 1.2rem; font-weight: bold;
            line-height: 28px; cursor: pointer; transition: background-color 0.2s;
            display: inline-flex; align-items: center; justify-content: center;
         }
         .add-entry-footer-btn:hover { background-color: #059669; }
         .delete-section-btn { /* Red 'X' button for dynamic sections */
             background: none; border: none; color: #ef4444;
             font-size: 1.3rem; /* Slightly larger X */
             cursor: pointer;
             padding: 0.4rem; /* Increased padding */
             line-height: 1; font-weight: bold;
             /* Visibility controlled by delete mode */
             opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s;
             display: inline-flex; /* Ensure alignment */
             align-items: center;
             justify-content: center;
         }
         .delete-mode-active .delete-section-btn {
             opacity: 1; visibility: visible;
         }
         .delete-section-btn:hover { color: #dc2626; }


        /* --- Grid Layout Spans (NEW INTUITIVE LAYOUT) --- */
        /* Row 1: Core Identity */
        .styled-section[data-section-id="header"] { grid-column: span 8; grid-row: 1; }
        .styled-section[data-section-id="characteristics"] { grid-column: span 4; grid-row: 1; }
        /* Row 2: Combat & Skills */
        .styled-section[data-section-id="combat-details"] { grid-column: span 8; grid-row: 2; }
        .styled-section[data-section-id="skills"] { grid-column: span 4; grid-row: 2; }
        /* Row 3: Inventory & Description */
        .styled-section[data-section-id="inventory"] { grid-column: span 4; grid-row: 3; }
        .styled-section[data-section-id="description"] { grid-column: span 8; grid-row: 3; }
        /* Row 4: Powers & Notes */
        .styled-section[data-section-id="powers"] { grid-column: span 4; grid-row: 4; }
        .styled-section[data-section-id="notes"] { grid-column: span 8; grid-row: 4; }

        /* Dynamic inventory sections still take full width when added */
        .dynamic-inventory-section { grid-column: span 12; }


        /* Input styling */
        input[type="text"], input[type="number"], textarea, select { /* Added select */
            width: 100%; padding: 0.3rem 0.5rem; border: 1px solid #ccc;
            border-radius: 4px; box-sizing: border-box; font-size: 0.9rem; margin-bottom: 0.25rem;
            background-color: white; /* Ensure select background is white */
        }
        /* Style specifically for readonly number inputs to look like text */
        input[type="number"][readonly].percent-display,
        input[type="text"][readonly].percent-display {
             -moz-appearance: textfield; /* Firefox */
             appearance: textfield;
             background-color: #e5e7eb; /* Gray background */
             cursor: default;
             border: 1px solid #d1d5db;
             color: #4b5563;
        }
        input[type="number"][readonly].percent-display::-webkit-outer-spin-button,
        input[type="number"][readonly].percent-display::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        select {
             appearance: none; /* Remove default arrow */
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%236b7280'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E"); /* Tailwind UI arrow */
             background-repeat: no-repeat;
             background-position: right 0.5rem center;
             background-size: 1.25em 1.25em;
             padding-right: 2.5rem; /* Make space for arrow */
        }
        textarea.auto-expand {
            line-height: 1.4; min-height: calc(1.4em + 0.6rem + 2px); /* Base height */
            height: calc(1.4em + 0.6rem + 2px); /* Initial height */
            resize: none; overflow: hidden; /* Hide scrollbar, resize handled by JS */
            white-space: normal; overflow-wrap: break-word; word-wrap: break-word; /* Ensure text wraps */
        }
        input[type="number"] { -moz-appearance: textfield; } /* Remove spinners in Firefox */
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; } /* Remove spinners in Chrome/Safari */
        label { display: block; margin-bottom: 0.25rem; font-size: 0.9rem; font-weight: 500; }

        /* Dynamic Entry Styling */
        .dynamic-entry { display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; }
        .dynamic-entry input, .dynamic-entry textarea { margin-bottom: 0; }
        /* Reduce width of text input in skills for better spacing */
        .dynamic-entry .skill-name-input { flex-grow: 1; width: auto; min-width: 80px; }
        /* Class for skill name display spans */
        .skill-name-display {
            flex-grow: 1; /* Allow skill name to take up space */
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: auto; /* Push rank/percent to right */
            padding-right: 0.5rem; /* Space before rank */
        }
        .remove-btn { /* Red minus button next to entries */
            background: none; border: none; cursor: pointer; font-size: 1.1rem; line-height: 1;
            padding: 0.2rem; color: #ef4444; transition: color 0.2s, opacity 0.2s, visibility 0.2s, width 0.2s, margin 0.2s, padding 0.2s; font-weight: bold;
            margin-right: 0.5rem; flex-shrink: 0;
            /* Hidden by default, shown in delete mode */
            opacity: 0; visibility: hidden; width: 0; margin-right: 0; padding: 0;
        }
        .delete-mode-active .remove-btn {
            opacity: 1; visibility: visible; width: auto; margin-right: 0.5rem; padding: 0.2rem;
        }
        .remove-btn:hover { color: #dc2626; }

        /* Skill Entry Specific Styling */
        .skill-entry { /* New class for skill entries */
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Consistent gap */
        }
        .skill-rank-input {
            width: 3rem !important; /* Fixed width for rank */
            text-align: center;
            flex-shrink: 0; /* Prevent shrinking */
        }
        /* Common styling for read-only percentage displays */
        .percent-display {
            text-align: center;
            background-color: #e5e7eb; /* Gray background */
            border: 1px solid #d1d5db;
            color: #4b5563; /* Darker gray text */
            cursor: default; /* Indicate non-editable */
            padding: 0.3rem 0.5rem; /* Match input padding */
            border-radius: 4px; /* Match input radius */
            font-size: 0.9rem; /* Match input font size */
            transition: background-color 0.1s ease-in-out, color 0.1s ease-in-out; /* Smooth transition for modifiers */
            flex-shrink: 0; /* Prevent shrinking */
            box-sizing: border-box; /* Include padding/border in width */
        }
        .skill-percent-display {
            width: 4rem !important; /* Fixed width for skill percentage display */
        }
        .characteristic-entry .percent-display {
             width: 100%; /* Make char percent take available space */
        }

        /* Modifier Styling for Percentage Displays */
        .percent-display.modifier-shift {
            background-color: #dcfce7 !important; /* Light green - Use !important to override base gray */
            color: #166534 !important; /* Dark green */
            font-weight: bold;
        }
        .percent-display.modifier-ctrl {
            background-color: #fee2e2 !important; /* Light red - Use !important to override base gray */
            color: #991b1b !important; /* Dark red */
            font-weight: bold;
        }


        /* Specific Layouts */
         /* Weapon entry grid layout - Added column for STR Mod */
         .weapon-entry {
             display: grid;
             /* Columns: RemoveBtn | Weapon Name | % Input | Damage Input | STR Mod | Notes | Roll Btn */
             grid-template-columns: auto 3fr 1fr 2fr auto 4fr auto;
             gap: 0.5rem; align-items: start; margin-bottom: 0.5rem;
         }
         .weapon-entry input, .weapon-entry textarea { margin-bottom: 0; }
         /* Header for weapon list - Added column for STR Mod */
         .weapon-header {
             display: grid;
             grid-template-columns: auto 3fr 1fr 2fr auto 4fr auto; /* Match entry columns */
             gap: 0.5rem; font-weight: bold; font-size: 0.8rem; margin-bottom: 0.25rem; color: #555;
             padding-left: 0;
         }
         /* Adjust header padding when delete buttons are visible */
         .delete-mode-active .weapon-header { padding-left: calc(20px + 0.5rem); } /* Match remove-btn width + gap */
         /* Weapon skill % input */
         .weapon-entry .skill-percent-input {
             width: 4rem !important; /* Fixed width like skill % display */
             text-align: center;
             flex-shrink: 0;
         }

         /* STR Damage Modifier Display */
         .str-dmg-mod {
             font-size: 0.8rem;
             color: #666;
             text-align: center;
             white-space: nowrap;
             padding-top: 0.3rem; /* Align vertically roughly with input */
             align-self: center; /* Center vertically in grid cell */
         }


         /* Grid for top header fields - Adjusted for Goal moving out */
         .header-fields-grid {
             display: grid;
             /* Columns: Name(3), Class(2), Profession(2), XP Earned(2), XP Spent(1) */
             grid-template-columns: 3fr 2fr 2fr 2fr 1fr;
             gap: 1rem;
             align-items: end; /* Align items to the bottom of the cell */
             margin-bottom: 1rem; /* Add space before Goal */
         }
         .header-fields-grid > div { /* Target direct children divs */
             margin-bottom: 0; /* Remove default margin from inputs inside */
         }
         #goal-container { /* Style the container for Goal */
             margin-top: 0; /* Remove potential top margin */
         }
         /* Styling for XP Spent field */
         #xp-spent {
             background-color: #e5e7eb; /* Light gray background */
             cursor: default;
             text-align: center;
             font-weight: bold;
             transition: color 0.2s ease-in-out; /* Smooth color transition */
         }
         .xp-spent-over { color: #dc2626; } /* Red */
         .xp-spent-equal { color: #16a34a; } /* Green */
         .xp-spent-under { color: #6b7280; } /* Gray */

          /* Responsive Header Grid */
         @media (max-width: 850px) { /* Adjust breakpoint as needed */
             .header-fields-grid {
                 grid-template-columns: 1fr 1fr 1fr; /* 3 columns */
             }
             .header-fields-grid > div:nth-child(1) { grid-column: 1 / -1; } /* Name full width */
             /* Class, Profession, XP Earned, XP Spent take one column each */
         }
         @media (max-width: 600px) {
              .header-fields-grid {
                 grid-template-columns: 1fr 1fr; /* 2 columns */
             }
              .header-fields-grid > div:nth-child(1) { grid-column: 1 / -1; } /* Name full width */
              /* Goal is already outside the grid */
         }


         /* Grid for description/flaws textareas */
         .description-fields-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
         /* Flex layout for combat skills */
         .combat-skills-grid { display: flex; justify-content: space-around; gap: 0.5rem; flex-wrap: wrap; }
         .combat-skills-grid .dynamic-entry { flex-basis: auto; border: 1px solid #eee; padding: 0.5rem; border-radius: 4px; background-color: #fff; min-width: 200px; /* Increased min-width slightly */ }
         /* Adjust width of combat skill text input */
         .combat-skills-grid .dynamic-entry input[type="text"] { width: 80px; flex-grow: 0; }

        /* Characteristics Styling */
        .characteristic-entry { /* Class for STR/DEX/CON rows */
             display: grid;
             /* Label | Input | % Display | Dice Btn */
             grid-template-columns: auto minmax(0, 1fr) minmax(0, 1fr) auto;
             gap: 0.5rem;
             align-items: center;
             margin-bottom: 0.5rem;
        }
        .characteristic-entry label { margin-bottom: 0; }
        .characteristic-entry input[type=number] { margin-bottom: 0; }
        /* .characteristic-entry .percent-display class handles styling */


        /* Hit Location Specific Styling */
        .hit-location-content {
            position: relative; width: 100%; aspect-ratio: 1 / 1; /* Maintain square aspect ratio */
            background-image: url('https://iili.io/3w2E1Uu.png'); /* Silhouette image */
            background-color: #ddd; /* Fallback color */
            background-size: contain; background-repeat: no-repeat; background-position: center;
            overflow: hidden; border-radius: 4px;
        }
        .hit-location {
            position: absolute; border: 1px solid #aaa; padding: 0.3rem; border-radius: 4px;
            text-align: center; font-size: 0.75rem; background-color: rgba(255, 255, 255, 0.75); /* Semi-transparent background */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); width: 18%; min-width: 60px; line-height: 1.2;
        }
        .hit-location label { font-weight: bold; display: block; margin-bottom: 0.1rem; font-size: 0.7rem; }
        .hp-ap-input { width: 30px; text-align: center; margin: 0 1px; font-size: 0.7rem; padding: 0.1rem; }
        .stat-line { display: flex; align-items: center; justify-content: center; gap: 0.1rem; margin-bottom: 0.1rem;}
        .stat-line label { margin-bottom: 0; font-weight: normal; font-size: 0.7rem; }
        .stat-line span { font-size: 0.7rem; }

        /* Positioning for hit location boxes */
        .hit-location[data-loc="head"] { top: 3%; left: 41%; }
        .hit-location[data-loc="chest"] { top: 25%; left: 41%; }
        .hit-location[data-loc="gut"] { top: 43%; left: 41%; }
        .hit-location[data-loc="l-arm"] { top: 28%; left: 15%; }
        .hit-location[data-loc="r-arm"] { top: 28%; right: 15%; }
        .hit-location[data-loc="l-leg"] { bottom: 5%; left: 28%; }
        .hit-location[data-loc="r-leg"] { bottom: 5%; right: 28%; }


        textarea { min-height: 60px; resize: vertical; } /* Allow vertical resize for textareas */

        /* Dice Roller Styles */
        .dice-roller-btn { cursor: pointer; font-size: 1rem; margin-left: 0.5rem; background: none; border: none; padding: 0; color: #555; flex-shrink: 0; }
        .dice-roller-btn:hover { color: #000; }
        #dice-result-popup {
            position: fixed; bottom: 20px; right: 20px; background-color: rgba(0, 0, 0, 0.8);
            color: white; padding: 10px 15px; border-radius: 5px; font-size: 1.2rem;
            z-index: 1001; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            white-space: pre-line; /* Allow line breaks */
            cursor: pointer; /* Indicate it's clickable to dismiss */
        }
        /* Style for special results in popup */
        .special-roll-text { font-weight: bold; color: #facc15; /* Yellow color */ margin-left: 0.5rem; }
        .critical-roll-text { font-weight: bold; color: #60a5fa; /* Blue color */ margin-left: 0.5rem; }
        .fumble-roll-text { font-weight: bold; color: #f87171; /* Red color */ margin-left: 0.5rem; }


        /* Responsive adjustments */
        @media (max-width: 900px) {
             .styled-section { grid-column: span 12 !important; } /* Stack all sections on medium screens */
             .hit-location { width: 22%; font-size: 0.7rem; }
             .hp-ap-input { width: 25px; }
             .description-fields-grid { grid-template-columns: 1fr; } /* Stack desc/flaws */
             /* Adjust top-right actions position */
             #sheet-actions-container { top: 0.2rem; right: 0.2rem; padding: 0.3rem; }
             #sheet-actions-container .action-btn { font-size: 0.8rem; padding: 0.2rem 0.4rem; }
        }
        @media (max-width: 600px) {
             /* Adjust weapon grid for smaller screens */
             .weapon-entry, .weapon-header {
                 grid-template-columns: auto 2fr 1fr 1fr auto 2fr auto; /* Adjust columns */
             }
             .hit-location-content { aspect-ratio: 2 / 3; } /* Adjust aspect ratio for taller screens */
             .hit-location { width: 28%; font-size: 0.65rem; padding: 0.2rem; }
             .hp-ap-input { width: 22px; }
             /* Adjust hit location positions for smaller screens */
             .hit-location[data-loc="l-arm"] { top: 25%; left: 5%; }
             .hit-location[data-loc="r-arm"] { top: 25%; right: 5%; }
             .hit-location[data-loc="l-leg"] { bottom: 3%; left: 15%; }
             .hit-location[data-loc="r-leg"] { bottom: 3%; right: 15%; }
             .skill-entry { flex-wrap: wrap; } /* Allow skill elements to wrap on small screens */
             .skill-name-display { width: 100%; margin-right: 0; margin-bottom: 0.25rem; } /* Skill name full width */
             .characteristic-entry { grid-template-columns: auto 1fr 1fr auto; } /* Adjust characteristic layout */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>

    <div class="character-sheet" id="character-sheet-container">

        <div id="sheet-actions-container">
            <button class="action-btn new-char-btn" onclick="resetCharacterSheet()" title="Start New Character">‚ú® New</button>
            <button class="action-btn" onclick="exportSheetData()" title="Export Sheet Data">üì§ Export</button>
            <button class="action-btn" onclick="document.getElementById('import-file-input').click()" title="Import Sheet Data">üì• Import</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="importSheetData(event)">
        </div>

        <div class="styled-section" data-section-id="header" data-deletable="false">
            <div class="section-header">
                <div class="section-title-container">
                    <span class="section-title-text">Wine-Dark Character Sheet</span>
                    <input type="text" class="section-title-input" value="Wine-Dark Character Sheet">
                    <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                </div>
                <div class="section-actions">
                     <button class="action-btn color-picker-btn" title="Change Color">
                         üé®
                         <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                     </button>
                     <button class="action-btn delete-mode-btn" onclick="toggleGlobalDeleteMode(this)" title="Toggle Delete Mode">üóëÔ∏è</button>
                </div>
            </div>
            <div class="section-content">
                <div class="header-fields-grid">
                    <div> <label for="char-name">Character Name:</label> <input type="text" id="char-name" placeholder="Enter Name"> </div>
                    <div>
                        <label for="char-class-select">Class:</label>
                        <select id="char-class-select" onchange="handleClassChange(this)">
                            <option value="Wretch">Wretch</option>
                            <option value="Serf">Serf</option>
                            <option value="Commoner" selected>Commoner</option>
                            <option value="Gentleman">Gentleman</option>
                            <option value="Noble">Noble</option>
                        </select>
                    </div>
                    <div> <label for="char-profession">Profession:</label> <input type="text" id="char-profession" placeholder="e.g., Shepherd, Merchant"> </div>
                    <div> <label for="char-experience">XP Earned:</label> <input type="number" id="char-experience" value="0" placeholder="100" oninput="updateXpSpent()"> </div>
                    <div> <label for="xp-spent">XP Spent:</label> <input type="number" id="xp-spent" value="0" readonly> </div>
                </div>
                <div id="goal-container">
                    <label for="char-goal">Goal:</label>
                    <input type="text" id="char-goal" placeholder="Enter current goal">
                </div>
            </div>
        </div>

        <div class="styled-section" data-section-id="characteristics" data-deletable="false">
            <div class="section-header">
                <div class="section-title-container">
                    <span class="section-title-text">Characteristics</span>
                    <input type="text" class="section-title-input" value="Characteristics">
                    <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                </div>
                <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                </div>
            </div>
            <div class="section-content">
                 <div class="characteristic-entry"> <label for="str" class="font-bold">STR</label> <input type="number" id="str" value="0" oninput="updatePercentages()"> <input type="text" id="str-percent" value="0%" class="percent-display" readonly> <button class="dice-roller-btn" onclick="rollCharacteristic(this, 'str')">üé≤</button> </div>
                <div class="characteristic-entry"> <label for="dex" class="font-bold">DEX</label> <input type="number" id="dex" value="0" oninput="updatePercentages()"> <input type="text" id="dex-percent" value="0%" class="percent-display" readonly> <button class="dice-roller-btn" onclick="rollCharacteristic(this, 'dex')">üé≤</button> </div>
                <div class="characteristic-entry"> <label for="con" class="font-bold">CON</label> <input type="number" id="con" value="0" oninput="updateHpDisplay(); updatePercentages();"> <input type="text" id="con-percent" value="0%" class="percent-display" readonly> <button class="dice-roller-btn" onclick="rollCharacteristic(this, 'con')">üé≤</button> </div>
                <div id="dynamic-stats-container"></div>
            </div>
        </div>

        <div class="styled-section" data-section-id="combat-details" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Combat Details</span>
                     <input type="text" class="section-title-input" value="Combat Details">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                 </div>
            </div>
            <div class="section-content">
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Combat Skills</span> </h4>
                     <div id="combat-skills-display" class="combat-skills-grid">
                         </div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('combat-skills-display', combatStatTemplate)" title="Add Combat Stat">+</button></div>
                 </div>
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Melee Weapons</span></h4>
                     <div class="weapon-header text-xs"> <span></span><span>Weapon</span><span>%</span><span>Damage</span><span>STR</span><span>Notes</span><span></span> </div>
                     <div id="melee-weapons-container"></div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('melee-weapons-container', meleeWeaponTemplate)" title="Add Melee Weapon">+</button></div>
                 </div>
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Ranged Weapons</span></h4>
                     <div class="weapon-header text-xs"> <span></span><span>Weapon</span><span>%</span><span>Damage</span><span>STR</span><span>Notes</span><span></span> </div>
                     <div id="ranged-weapons-container"></div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('ranged-weapons-container', rangedWeaponTemplate)" title="Add Ranged Weapon">+</button></div>
                 </div>
                 <div class="sub-section">
                      <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Hit Locations</span></h4>
                      <div class="section-content hit-location-content p-0">
                          <div class="hit-location" data-loc="head"> <label>Head</label> <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input">/<input type="number" value="0" class="hp-ap-input"></div> <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="head">/<span class="hp-max" data-location="head">0</span></div> </div>
                          <div class="hit-location" data-loc="l-arm"> <label>L. Arm</label> <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input">/<input type="number" value="0" class="hp-ap-input"></div> <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="arm">/<span class="hp-max" data-location="arm">0</span></div> </div>
                          <div class="hit-location" data-loc="chest"> <label>Chest</label> <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input">/<input type="number" value="0" class="hp-ap-input"></div> <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="chest">/<span class="hp-max" data-location="chest">0</span></div> </div>
                          <div class="hit-location" data-loc="r-arm"> <label>R. Arm</label> <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input">/<input type="number" value="0" class="hp-ap-input"></div> <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="arm">/<span class="hp-max" data-location="arm">0</span></div> </div>
                          <div class="hit-location" data-loc="gut"> <label>Gut</label> <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input">/<input type="number" value="0" class="hp-ap-input"></div> <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="abdomen">/<span class="hp-max" data-location="abdomen">0</span></div> </div>
                          <div class="hit-location" data-loc="l-leg"> <label>L. Leg</label> <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input">/<input type="number" value="0" class="hp-ap-input"></div> <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="leg">/<span class="hp-max" data-location="leg">0</span></div> </div>
                          <div class="hit-location" data-loc="r-leg"> <label>R. Leg</label> <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input">/<input type="number" value="0" class="hp-ap-input"></div> <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="leg">/<span class="hp-max" data-location="leg">0</span></div> </div>
                    </div>
                 </div>
            </div>
        </div>

        <div class="styled-section" data-section-id="skills" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Skills</span>
                     <input type="text" class="section-title-input" value="Skills">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                 </div>
             </div>
            <div class="section-content text-sm">
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Core Skills</span></h4>
                     <div id="skills-container">
                          </div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('skills-container', skillTemplate)" title="Add Skill">+</button></div>
                 </div>
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Knowledge</span></h4>
                     <div id="knowledge-container">
                          </div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('knowledge-container', knowledgeTemplate)" title="Add Knowledge">+</button></div>
                 </div>
                 <div class="sub-section">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Craft / Art</span></h4>
                     <div id="craft-art-container"></div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('craft-art-container', craftArtTemplate)" title="Add Craft/Art">+</button></div>
                 </div>
            </div>
        </div>

        <div class="styled-section" data-section-id="inventory" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Inventory</span>
                     <input type="text" class="section-title-input" value="Inventory">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                 </div>
             </div>
            <div class="section-content">
                <div class="sub-section mb-4 border-b pb-4"> <h4 class="font-semibold mb-1 text-sm">Backpack (5 slots)</h4> <input type="text" placeholder="Slot 1"> <input type="text" placeholder="Slot 2"> <input type="text" placeholder="Slot 3"> <input type="text" placeholder="Slot 4"> <input type="text" placeholder="Slot 5"> </div>
                <div class="sub-section mb-4 border-b pb-4">
                    <h4 class="font-semibold mb-1 text-sm">Satchel</h4>
                    <textarea placeholder="List satchel items..."></textarea>
                    <label for="coin" class="mt-2">Coin:</label>
                    <input type="number" id="coin" value="10">
                     <div class="text-center mt-4">
                         <button onclick="addInventorySection()" class="add-entry-footer-btn" title="Add Inventory Container">+</button>
                     </div>
                 </div>
                 <div id="dynamic-inventory-container" class="grid grid-cols-1 gap-4"></div>
             </div>
        </div>

        <div class="styled-section" data-section-id="description" data-deletable="true">
            <div class="section-header">
                <div class="section-title-container">
                    <span class="section-title-text">Description & Flaws</span>
                    <input type="text" class="section-title-input" value="Description & Flaws">
                    <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                </div>
                <div class="section-actions">
                     <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                </div>
            </div>
            <div class="section-content description-fields-grid">
                 <div>
                     <textarea id="char-desc" placeholder="Enter character description, goals..." class="h-full"></textarea>
                 </div>
                 <div>
                     <textarea id="char-flaws" placeholder="Enter descriptions of your character's vices, fears, and misfortunes. Describe how they affect your character." class="h-full"></textarea>
                 </div>
            </div>
        </div>

        <div class="styled-section" data-section-id="powers" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Powers</span>
                     <input type="text" class="section-title-input" value="Powers">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                 </div>
            </div>
             <div id="powers-container" class="section-content"></div>
             <div class="section-footer"><button class="add-entry-footer-btn" onclick="addEntry('powers-container', powerTemplate)" title="Add Power/Note">+</button></div>
         </div>

         <div class="styled-section" data-section-id="notes" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Notes</span>
                     <input type="text" class="section-title-input" value="Notes">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                 </div>
            </div>
             <div id="notes-container" class="section-content">
                 <textarea placeholder="General notes..." class="h-full"></textarea>
             </div>
         </div>

    </div> <div id="dice-result-popup" onclick="this.style.display='none'"></div>


    <script>
        // --- Constants ---
        const LOCAL_STORAGE_KEY = 'wineDarkSheetData_v3'; // Use a versioned key

        // --- Template Strings for Dynamic Entries ---
        // Added 'percent-display' class to skill templates
        const skillTemplate = `<div class="dynamic-entry skill-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Skill">-</button><input type="text" placeholder="Skill Name" class="skill-name-input flex-grow" data-base-skill="" data-base-percent="0" oninput="updateDynamicSkillLabel(this)"><input type="number" value="0" class="skill-rank-input" oninput="updateSkillPercentage(this)"><input type="number" value="0" class="skill-percent-display percent-display" readonly><button class="dice-roller-btn" onclick="rollPercentile(this)">üé≤</button></div>`;
        const knowledgeTemplate = `<div class="dynamic-entry skill-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Knowledge">-</button><input type="text" placeholder="Knowledge Area" class="skill-name-input flex-grow" data-base-skill="" data-base-percent="0" oninput="updateDynamicSkillLabel(this)"><input type="number" value="0" class="skill-rank-input" oninput="updateSkillPercentage(this)"><input type="number" value="0" class="skill-percent-display percent-display" readonly><button class="dice-roller-btn" onclick="rollPercentile(this)">üé≤</button></div>`;
        const craftArtTemplate = `<div class="dynamic-entry skill-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Craft/Art">-</button><input type="text" placeholder="Craft/Art Name" class="skill-name-input flex-grow" data-base-skill="" data-base-percent="0" oninput="updateDynamicSkillLabel(this)"><input type="number" value="0" class="skill-rank-input" oninput="updateSkillPercentage(this)"><input type="number" value="0" class="skill-percent-display percent-display" readonly><button class="dice-roller-btn" onclick="rollPercentile(this)">üé≤</button></div>`;
        const combatStatTemplate = `<div class="dynamic-entry skill-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Stat">-</button><input type="text" placeholder="Combat Stat Name" class="skill-name-input flex-grow" data-base-skill="" data-base-percent="0" oninput="updateDynamicSkillLabel(this)"><input type="number" value="0" class="skill-rank-input" oninput="updateSkillPercentage(this)"><input type="number" value="0" class="skill-percent-display percent-display" readonly><button class="dice-roller-btn" onclick="rollPercentile(this)">üé≤</button></div>`;

        // Weapon Templates - Added oninput handler to skill percent input
        const meleeWeaponTemplate = `<div class="dynamic-entry weapon-entry" data-weapon-type="melee"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Weapon">-</button><textarea placeholder="Weapon Name" class="auto-expand" rows="1" oninput="autoExpandTextarea(this)"></textarea><input type="number" value="0" class="text-center skill-percent-input" oninput="updateXpSpent()"><input type="text" placeholder="e.g. 1d4" class="dmg-input"><span class="str-dmg-mod">(+0)</span><textarea placeholder="Notes" class="auto-expand" rows="1" oninput="autoExpandTextarea(this)"></textarea><button class="dice-roller-btn" onclick="rollWeaponAttack(this)">üé≤</button></div>`;
        const rangedWeaponTemplate = `<div class="dynamic-entry weapon-entry" data-weapon-type="ranged"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Weapon">-</button><textarea placeholder="Weapon Name" class="auto-expand" rows="1" oninput="autoExpandTextarea(this)"></textarea><input type="number" value="0" class="text-center skill-percent-input" oninput="updateXpSpent()"><input type="text" placeholder="e.g. 1d6" class="dmg-input"><span class="str-dmg-mod">(+0)</span><textarea placeholder="Notes" class="auto-expand" rows="1" oninput="autoExpandTextarea(this)"></textarea><button class="dice-roller-btn" onclick="rollWeaponAttack(this)">üé≤</button></div>`;
        const powerTemplate = `<div class="dynamic-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Power/Note">-</button><input type="text" placeholder="Power or Note" class="flex-grow"></div>`;
        const inventorySlotTemplate = `<div class="dynamic-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Slot">-</button><input type="text" placeholder="Item Slot" class="flex-grow"></div>`;

        // --- Default Sheet Structure (for Reset) ---
        const defaultSheetStructure = {
            skills: {
                core: [
                    { baseSkill: "Climb", basePercent: 0, attribute: "STR", multiplier: 2 },
                    { baseSkill: "Disguise", basePercent: 1 },
                    { baseSkill: "First Aid", basePercent: 30 },
                    { baseSkill: "Herbalism", basePercent: 5 },
                    { baseSkill: "Hide", basePercent: 10 },
                    { baseSkill: "Knots", basePercent: 10 },
                    { baseSkill: "Listen", basePercent: 25 },
                    { baseSkill: "Research", basePercent: 25 },
                    { baseSkill: "Spot", basePercent: 25 },
                    { baseSkill: "Teach", basePercent: 10 },
                    { baseSkill: "Track", basePercent: 10 }
                ],
                knowledge: [
                    { baseSkill: "Church", basePercent: 0 },
                    { baseSkill: "Law", basePercent: 0 },
                    { baseSkill: "Literacy", basePercent: 0 },
                    { baseSkill: "Sport", basePercent: 0 }
                ],
                craftArt: [] // Starts empty
            },
            combat: {
                skills: [
                    { baseSkill: "Melee", basePercent: 25 },
                    { baseSkill: "Range", basePercent: 25 },
                    { baseSkill: "Dodge", basePercent: 0, attribute: "DEX", multiplier: 2 }
                ],
                meleeWeapons: [],
                rangedWeapons: []
            }
        };

        // --- Debounce Utility ---
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        // --- Local Storage Functions ---
        function saveSheetToLocalStorage() {
            try {
                const sheetData = gatherSheetData();
                const jsonData = JSON.stringify(sheetData);
                localStorage.setItem(LOCAL_STORAGE_KEY, jsonData);
                 console.log("Sheet data saved to local storage."); // DEBUGGING
            } catch (error) {
                console.error("Error saving sheet data to local storage:", error);
                showDicePopup("Error saving sheet data. See console.");
            }
        }

        // Create a debounced version of the save function
        const debouncedSave = debounce(saveSheetToLocalStorage, 500); // Save 500ms after last change

        function loadSheetFromLocalStorage() {
            console.log("Attempting to load sheet from local storage..."); // DEBUGGING
            try {
                const jsonData = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (jsonData) {
                    console.log("Found saved data:", jsonData); // DEBUGGING
                    const data = JSON.parse(jsonData);
                    // Basic validation - check if it looks like our data
                    // Loosened version check slightly for backward compatibility if needed
                    if (typeof data === 'object' && data !== null && data.version && data.version >= 2) {
                        console.log("Parsed data version:", data.version); // DEBUGGING
                        setDefaultSheetState(false); // Reset sheet without recalculating yet
                        populateSheetData(data);
                        console.log("Sheet data loaded successfully from local storage."); // DEBUGGING
                        // Recalculate everything *after* populating
                        updateHpDisplay();
                        updatePercentages();
                        updateXpSpent();
                        return true; // Indicate successful load
                    } else {
                        console.warn("Invalid or outdated data found in local storage. Version:", data?.version); // DEBUGGING
                        localStorage.removeItem(LOCAL_STORAGE_KEY); // Remove invalid data
                    }
                } else {
                    console.log("No data found in local storage for key:", LOCAL_STORAGE_KEY); // DEBUGGING
                }
            } catch (error) {
                console.error("Error loading or parsing sheet data from local storage:", error); // DEBUGGING
                showDicePopup("Error loading saved data. Resetting. See console.");
                localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear potentially corrupted data
            }

            // If function hasn't returned true, it means loading failed or no data found
            console.log("Loading failed or no data found. Setting default state."); // DEBUGGING
            setDefaultSheetState(true); // Set default state and calculate
            return false; // Indicate load failed or no data
        }


        // --- Auto-expand Textarea ---
        function autoExpandTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }

        // --- Core Add/Remove Functions ---
        function addEntry(containerId, template, data = null) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error("Container not found:", containerId);
                return;
            }

            container.insertAdjacentHTML('beforeend', template);
            const newEntry = container.lastElementChild;

            // Initialize auto-expand for textareas
            newEntry.querySelectorAll('textarea.auto-expand').forEach(ta => {
                ta.addEventListener('input', () => autoExpandTextarea(ta));
                autoExpandTextarea(ta); // Initial call
            });

            // Populate data if provided (for import or load)
            if (data) {
                if (newEntry.classList.contains('skill-entry')) {
                    const nameInput = newEntry.querySelector('.skill-name-input');
                    const rankInput = newEntry.querySelector('.skill-rank-input');
                    const nameSpan = newEntry.querySelector('.skill-name-display');

                    // Determine if it's a predefined skill (has baseSkill in definition)
                    // or a dynamic one (added by user, identified by 'name' in saved data)
                    const isPredefined = data.baseSkill && defaultSheetStructure.skills.core.some(def => def.baseSkill === data.baseSkill) ||
                                        data.baseSkill && defaultSheetStructure.skills.knowledge.some(def => def.baseSkill === data.baseSkill) ||
                                        data.baseSkill && defaultSheetStructure.combat.skills.some(def => def.baseSkill === data.baseSkill);

                    if (isPredefined && nameSpan) { // Populate predefined skill (using span)
                        nameSpan.dataset.baseSkill = data.baseSkill;
                        nameSpan.dataset.basePercent = data.basePercent || 0;
                        if (data.attribute) nameSpan.dataset.attribute = data.attribute;
                        if (data.multiplier) nameSpan.dataset.multiplier = data.multiplier;
                        // Label text content will be set by updateSkillPercentage
                    } else if (!isPredefined && nameInput) { // Populate dynamic skill (using input)
                        nameInput.value = data.name || data.baseSkill || ''; // Use name, fallback to baseSkill if name missing
                        nameInput.dataset.baseSkill = data.name || data.baseSkill || '';
                        nameInput.dataset.basePercent = data.basePercent || 0;
                    } else if (nameInput && data.baseSkill && !data.name) {
                        // Handle case where a predefined skill might have been saved with only baseSkill
                        // This case might occur if gatherSheetData wasn't perfect before
                        nameInput.value = data.baseSkill;
                        nameInput.dataset.baseSkill = data.baseSkill;
                        nameInput.dataset.basePercent = data.basePercent || 0;
                    }


                    if (rankInput && data.rank !== undefined) rankInput.value = data.rank;
                    updateSkillPercentage(rankInput); // Update display after setting rank
                }
                else if (newEntry.classList.contains('weapon-entry')) {
                    const nameTextarea = newEntry.querySelector('textarea[placeholder="Weapon Name"]');
                    const percentInput = newEntry.querySelector('.skill-percent-input');
                    const dmgInput = newEntry.querySelector('.dmg-input');
                    const notesTextarea = newEntry.querySelector('textarea[placeholder="Notes"]');
                    if (nameTextarea && data.name !== undefined) nameTextarea.value = data.name;
                    if (percentInput && data.percent !== undefined) percentInput.value = data.percent;
                    if (dmgInput && data.damage !== undefined) dmgInput.value = data.damage;
                    if (notesTextarea && data.notes !== undefined) notesTextarea.value = data.notes;
                    autoExpandTextarea(nameTextarea); // Ensure correct height
                    autoExpandTextarea(notesTextarea);
                    updateStrDamageModifiers(); // Update STR mod display
                }
                else if (newEntry.querySelector('input[placeholder="Item Slot"]')) { // Inventory Slot
                     const itemInput = newEntry.querySelector('input[placeholder="Item Slot"]');
                     if(itemInput && data.item !== undefined) itemInput.value = data.item;
                }
                 else if (newEntry.querySelector('input[placeholder="Power or Note"]')) { // Power/Note
                     const powerInput = newEntry.querySelector('input[placeholder="Power or Note"]');
                     if(powerInput && data.text !== undefined) powerInput.value = data.text;
                }
            }

            // Update XP Spent if a skill or weapon % was added (even if data wasn't provided initially)
            if (newEntry.classList.contains('skill-entry') || newEntry.querySelector('.skill-percent-input')) {
                updateXpSpent(); // Ensure XP updates correctly when adding new blank entries
            }
             // Save is triggered by the main event listener, not needed here
             // debouncedSave();
        }

        function removeEntry(buttonElement) {
            const entry = buttonElement.closest('.dynamic-entry');
            if (entry) {
                const isSkill = entry.classList.contains('skill-entry');
                const isWeapon = entry.classList.contains('weapon-entry');
                entry.remove();
                // Update XP Spent if a skill or weapon was removed
                if (isSkill || isWeapon) {
                    updateXpSpent();
                }
                 // Save after removing an entry
                 debouncedSave();
            }
        }

        // --- Inventory Section Functions ---
        let sectionCounter = 0;
        function addInventorySection(data = null) {
            sectionCounter++;
            const slotsContainerId = `dynamic-inventory-slots-${sectionCounter}`;
            const sectionId = `dynamic-inventory-section-${sectionCounter}`;
            const title = data?.title || `New Inventory ${sectionCounter}`;
            const color = data?.color || getRandomColor(); // Use imported color or random

            const inventorySectionTemplate = `
                <div id="${sectionId}" class="styled-section dynamic-inventory-section" data-section-id="${sectionId}" data-deletable="true">
                     <div class="section-header" style="background-color: ${color};">
                         <div class="section-title-container">
                             <span class="section-title-text">${title}</span>
                             <input type="text" class="section-title-input" value="${title}">
                             <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                         </div>
                         <div class="section-actions">
                              <button class="action-btn color-picker-btn" title="Change Color">
                                  üé®
                                  <input type="color" class="color-picker-input" value="${color}" onchange="changeSectionColor(this)">
                              </button>
                              <button class="delete-section-btn" onclick="removeFullSection(this)" title="Delete Section">X</button>
                         </div>
                     </div>
                     <div id="${slotsContainerId}" class="section-content">
                         ${!data ? `<div class="dynamic-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Slot">-</button> <input type="text" placeholder="Item Slot" class="flex-grow"> </div>` : ''}
                     </div>
                      <div class="section-footer"><button class="add-entry-footer-btn" onclick="addEntry('${slotsContainerId}', inventorySlotTemplate)" title="Add Slot">+</button></div>
                 </div>`;
            document.getElementById('dynamic-inventory-container')?.insertAdjacentHTML('beforeend', inventorySectionTemplate);

            // Populate slots if data is provided
            if (data && data.items) {
                const slotsContainer = document.getElementById(slotsContainerId);
                if (slotsContainer) {
                    // Use a temporary flag to prevent saving during population loop
                    const initialPopulation = true;
                    data.items.forEach(itemData => addEntry(slotsContainerId, inventorySlotTemplate, itemData));
                }
            }
            // Save after adding section (if not part of initial load)
            if (!data) { // Only save if it's a user action, not during load
                 debouncedSave();
            }
        }


        // --- Generic Section Management ---
        function removeFullSection(buttonElement) {
             const section = buttonElement.closest('.styled-section');
             if (section && section.dataset.deletable === 'true') {
                 if (confirm('Are you sure you want to delete this entire section?')) {
                     section.remove();
                     debouncedSave(); // Save after removing section
                 }
             }
        }

        function toggleTitleEdit(buttonElement) {
            const titleContainer = buttonElement.closest('.section-title-container');
            const titleText = titleContainer.querySelector('.section-title-text');
            const titleInput = titleContainer.querySelector('.section-title-input');
            if (!titleContainer || !titleText || !titleInput) return;

            const saveEdit = () => {
                titleText.textContent = titleInput.value;
                titleContainer.classList.remove('editing');
                titleInput.onblur = null;
                titleInput.onkeydown = null;
                debouncedSave(); // Save after editing title
            };

            const cancelEdit = () => {
                titleInput.value = titleText.textContent; // Revert input value
                titleContainer.classList.remove('editing');
                titleInput.onblur = null;
                titleInput.onkeydown = null;
                // No save needed on cancel
            }

            if (titleContainer.classList.contains('editing')) {
                saveEdit();
            } else {
                titleInput.value = titleText.textContent;
                titleContainer.classList.add('editing');
                titleInput.focus();
                titleInput.select();
                // Save on blur (when focus is lost)
                titleInput.onblur = saveEdit;
                // Handle Enter/Escape keys
                titleInput.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault(); // Prevent form submission if any
                        titleInput.blur(); // Trigger saveEdit via blur
                    } else if (event.key === 'Escape') {
                        cancelEdit();
                    }
                };
            }
        }
        function changeSectionColor(colorInputElement) {
             colorInputElement.closest('.section-header')?.style.setProperty('background-color', colorInputElement.value);
             // Save is triggered by the main event listener
             // debouncedSave();
         }
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 10)];
            }
            return color;
        }

        // --- Delete Mode ---
        function toggleGlobalDeleteMode(buttonElement) {
            const container = document.getElementById('character-sheet-container');
            if (container) {
                container.classList.toggle('delete-mode-active');
                buttonElement.classList.toggle('active');
                // No save needed for toggling delete mode itself
            }
        }

        // --- Dice Rolling Helper ---
        function rollSingleDie(sides) {
            // Ensure minimum sides is 1
            sides = Math.max(1, sides);
            return Math.floor(Math.random() * sides) + 1;
        }

        // --- Dice Parsing and Calculation Helpers ---

        /**
         * Parses a dice string (e.g., "1d6+2", "d8", "+2d4", "-1d6", "5") into components.
         * @param {string} diceString - The dice string to parse.
         * @returns {object} An object { numDice, numSides, flatModifier, sign }
         */
        function parseDiceString(diceString) {
            diceString = String(diceString || '0').toLowerCase().replace(/\s+/g, ''); // Ensure string, clean up
            let numDice = 0;
            let numSides = 0;
            let flatModifier = 0;
            let sign = '+'; // Default sign

            // Check for initial sign (+ or -) for modifier dice like (+2d4) or (-1d6)
            if (diceString.startsWith('+') || diceString.startsWith('-')) {
                sign = diceString[0];
                diceString = diceString.substring(1); // Remove sign for further parsing
            }

            // Regex for dice part (e.g., 1d6, 2d8, d10)
            const diceRegex = /(\d+)?d(\d+)/;
            // Regex for flat modifier part (e.g., +2, -1) attached to dice
            const flatModRegex = /([+-]\d+)$/;

            // Find flat modifier attached to dice first (e.g., in "1d6+2")
            const flatMatch = diceString.match(flatModRegex);
            if (flatMatch) {
                flatModifier = parseInt(flatMatch[1]);
                diceString = diceString.slice(0, flatMatch.index); // Remove modifier part
            }

            // Match the remaining dice part
            const diceMatch = diceString.match(diceRegex);
            if (diceMatch) {
                numDice = diceMatch[1] ? parseInt(diceMatch[1]) : 1; // Default to 1 die if number omitted (e.g., "d6")
                numSides = parseInt(diceMatch[2]);
            } else if (!isNaN(parseInt(diceString))) {
                // If it's just a flat number (e.g., "5" or "+3" after sign removal)
                numDice = 0;
                numSides = 0;
                flatModifier = parseInt(diceString); // Use this as the flat modifier
            }
            // else: Invalid format, all values remain 0

            return { numDice, numSides, flatModifier, sign };
        }

        /**
         * Rolls dice based on parsed components.
         * @param {object} parsedResult - The result from parseDiceString.
         * @returns {object} An object { totalValue, rollsString }
         */
        function rollParsedDice(parsedResult) {
            let diceTotal = 0;
            let rolls = [];
            for (let i = 0; i < parsedResult.numDice; i++) {
                const roll = rollSingleDie(parsedResult.numSides);
                rolls.push(roll);
                diceTotal += roll;
            }

            // Combine dice total with flat modifier
            let totalValue = diceTotal + parsedResult.flatModifier;
            let signPrefix = parsedResult.sign;

            // Build the string representation
            let rollsString = "";
            if (parsedResult.numDice > 0) {
                rollsString = `${parsedResult.numDice}d${parsedResult.numSides} (${rolls.join(', ')})`;
                if (parsedResult.flatModifier !== 0) {
                    rollsString += (parsedResult.flatModifier > 0 ? ` +${parsedResult.flatModifier}` : ` ${parsedResult.flatModifier}`);
                }
            } else if (parsedResult.flatModifier !== 0) { // Only flat modifier
                 rollsString = `${parsedResult.flatModifier}`;
            } else { // No dice, no modifier (e.g., input was "0" or invalid)
                 rollsString = "0";
            }

             // Prepend sign only if it's negative or if there were dice involved
            if (parsedResult.sign === '-' || parsedResult.numDice > 0) {
                 rollsString = signPrefix + rollsString;
            }
             // Apply sign for modifier dice total value AFTER string is built
             if (parsedResult.sign === '-') {
                totalValue = -totalValue;
            }

            // Remove leading '+' if it's the only thing or redundant (e.g., "+0")
             if (rollsString === "+0") rollsString = "0";
             else if (rollsString.startsWith('+') && parsedResult.numDice === 0) rollsString = rollsString.substring(1);


            return { totalValue: totalValue, rollsString }; // Allow negative results here, clamp later
        }

        /**
         * Calculates the maximum possible value from parsed dice components.
         * @param {object} parsedResult - The result from parseDiceString.
         * @returns {number} The maximum possible value.
         */
        function getMaxParsedDice(parsedResult) {
             let maxDiceValue = parsedResult.numDice * parsedResult.numSides;
             let maxValue = maxDiceValue + parsedResult.flatModifier;
             // Apply sign for modifier dice
             if (parsedResult.sign === '-') {
                 maxValue = -maxValue;
             }
             return maxValue;
        }


        // --- Dice Roller & Related Functions ---
        const dicePopup = document.getElementById('dice-result-popup');
        let currentRoller = null;

        function showDicePopup(content) {
            dicePopup.innerHTML = content;
            dicePopup.style.display = 'block';
        }

        function rollPercentile(buttonElement) {
            if (currentRoller === buttonElement && dicePopup.style.display === 'block') {
                dicePopup.style.display = 'none';
                currentRoller = null;
                return;
            }

            const entry = buttonElement.closest('.dynamic-entry');
            // Read the *currently displayed* percentage value (handles modifiers)
            const skillPercentDisplay = entry?.querySelector('.skill-percent-display');
            const skillValue = skillPercentDisplay ? parseInt(skillPercentDisplay.value) || 0 : 0;

            // Get skill name from the display span or input
            const skillNameElement = entry?.querySelector('.skill-name-display') || entry?.querySelector('.skill-name-input');
            let skillName = "Skill"; // Default
            if (skillNameElement) {
                skillName = skillNameElement.dataset.baseSkill || // Use data-base-skill if present
                            (skillNameElement.tagName === 'SPAN' ? skillNameElement.textContent.split(' (')[0] : skillNameElement.value) || // Get text/value and remove parenthetical
                            "Skill"; // Fallback
            }


            const roll = rollSingleDie(100);
            const success = roll <= skillValue && roll < 100; // 100 always fails skills
            const resultColor = success ? '#4ade80' : '#f87171'; // Green/Red

            let popupContent = `<span style="color:${resultColor}; font-weight: bold;">${roll}</span> <span class="text-xs ml-2">vs ${skillValue}% (${skillName})</span>`;

            // Check for skill fumble
            if (roll === 100) {
                popupContent += `<span class="fumble-roll-text">Fumble!</span>`;
            }

            showDicePopup(popupContent);
            currentRoller = buttonElement;
        }

        // Updated function to roll characteristic percentile, considering modifiers
        function rollCharacteristic(buttonElement, charName) {
             if (currentRoller === buttonElement && dicePopup.style.display === 'block') {
                dicePopup.style.display = 'none';
                currentRoller = null;
                return;
            }
            const percentDisplay = document.getElementById(`${charName}-percent`);
            // Read the *currently displayed* value from the field (handles modifiers)
            let charValue = percentDisplay ? parseInt(percentDisplay.value.replace('%','')) || 0 : 0;
            const charLabel = charName.toUpperCase();

            const roll = rollSingleDie(100);
            const success = roll <= charValue && roll < 100; // 100 always fails
            const resultColor = success ? '#4ade80' : '#f87171';

            let popupContent = `<span style="color:${resultColor}; font-weight: bold;">${roll}</span> <span class="text-xs ml-2">vs ${charValue}% (${charLabel})</span>`;
             if (roll === 100) {
                popupContent += `<span class="fumble-roll-text">Fumble!</span>`;
            }
             showDicePopup(popupContent);
             currentRoller = buttonElement;
        }


        function rollWeaponAttack(buttonElement) {
             if (currentRoller === buttonElement && dicePopup.style.display === 'block') {
                 dicePopup.style.display = 'none';
                 currentRoller = null;
                 return;
             }

             const entry = buttonElement.closest('.dynamic-entry');
             const weaponNameInput = entry?.querySelector('textarea[placeholder="Weapon Name"]');
             const weaponName = weaponNameInput?.value || 'Weapon';
             const dmgInput = entry?.querySelector('.dmg-input');
             const baseDmgString = dmgInput?.value || '0'; // Base damage from input
             const strModElement = entry?.querySelector('.str-dmg-mod');
             const strModString = strModElement ? strModElement.textContent : '(+0)'; // e.g., "(+1d4)"

             // Get Attack Skill
             const weaponType = entry?.dataset.weaponType;
             const weaponSkillInput = entry?.querySelector('.skill-percent-input');
             const weaponSkillValue = weaponSkillInput ? parseInt(weaponSkillInput.value) || 0 : 0;

             // Find the corresponding base combat skill (Melee or Range) percentage
             const baseCombatSkillSelector = weaponType === 'melee'
                 ? '#combat-skills-display .skill-entry [data-base-skill="Melee"]' // More general selector
                 : '#combat-skills-display .skill-entry [data-base-skill="Range"]';
             const baseCombatSkillElement = document.querySelector(baseCombatSkillSelector);
             const baseSkillPercentDisplay = baseCombatSkillElement?.closest('.skill-entry')?.querySelector('.skill-percent-display');
             const baseSkillValue = baseSkillPercentDisplay ? parseInt(baseSkillPercentDisplay.value) || 0 : 0;

             const totalSkillValue = Math.min(75, baseSkillValue + weaponSkillValue); // Capped at 75

             // --- Roll Attack ---
             const roll = rollSingleDie(100);
             let specialResultText = ""; // For Crit/Special/Fumble text
             let isCrit = roll <= 2;
             let isSpecial = roll >= 3 && roll <= 15;
             let isFumble = roll >= 96; // Fumble on 96-100

             // Determine success (Crit auto-hits if skill > 0, Fumble auto-misses)
             let success = (roll <= totalSkillValue && !isFumble) || (isCrit && totalSkillValue > 0);

             // Build initial popup string (Attack Roll)
             const resultColor = success ? '#4ade80' : '#f87171';
             let popupContent = `<span style="font-weight: bold;">${weaponName}: </span>`;
             popupContent += `<span style="color:${resultColor}; font-weight: bold;">${roll}</span> <span class="text-xs ml-1">vs ${totalSkillValue}%</span>`;

             // --- Handle Attack Result ---
             if (isFumble) {
                 specialResultText = `<span class="fumble-roll-text">Fumble!</span>`;
                 success = false; // Ensure fumble is a miss
                 popupContent += specialResultText;
             } else if (success) {
                 // --- Calculate Damage ---
                 const hitLocation = getHitLocation();
                 let totalFinalDamage = 0;
                 let damageResultString = "";

                 // Parse base damage and STR modifier
                 const parsedBaseDmg = parseDiceString(baseDmgString);
                 const parsedStrMod = parseDiceString(strModString.replace(/[()]/g, '')); // Remove () before parsing

                 if (isCrit) {
                     specialResultText = `<span class="critical-roll-text">Critical! Bypass Armor!</span>`;
                     const maxBase = getMaxParsedDice(parsedBaseDmg);
                     const maxMod = getMaxParsedDice(parsedStrMod);
                     totalFinalDamage = Math.max(0, maxBase + maxMod);
                     damageResultString = `Max ${baseDmgString}${strModString} = <span style="font-weight:bold;">${totalFinalDamage}</span> Damage`;
                 } else if (isSpecial) {
                     specialResultText = `<span class="special-roll-text">Special! Max Damage!</span>`;
                     const maxBase = getMaxParsedDice(parsedBaseDmg);
                     const maxMod = getMaxParsedDice(parsedStrMod);
                     totalFinalDamage = Math.max(0, maxBase + maxMod);
                     damageResultString = `Max ${baseDmgString}${strModString} = <span style="font-weight:bold;">${totalFinalDamage}</span> Damage`;
                 } else { // Normal Hit
                     const { totalValue: rolledBase, rollsString: baseRolls } = rollParsedDice(parsedBaseDmg);
                     const { totalValue: rolledMod, rollsString: modRolls } = rollParsedDice(parsedStrMod);
                     totalFinalDamage = Math.max(0, rolledBase + rolledMod); // Clamp final damage at 0

                     // Build the detailed roll string
                     damageResultString = baseRolls;
                     if (modRolls && modRolls !== "0") { // Add modifier string only if it exists and isn't zero
                        // Add space and explicit sign if needed
                        if (!modRolls.startsWith('+') && !modRolls.startsWith('-')) {
                            damageResultString += " + ";
                        } else {
                            damageResultString += " "; // Add space before signed modifier
                        }
                         damageResultString += modRolls;
                     }
                     damageResultString += ` = <span style="font-weight:bold;">${totalFinalDamage}</span> Damage`;
                 }

                 // Add special result text and damage string to popup
                 popupContent += specialResultText;
                 popupContent += `\n<span style="font-size: 0.9em;">${damageResultString} to <span style="font-weight:bold;">${hitLocation}</span></span>`;

             } else { // Miss (and not a fumble)
                 popupContent += `\n<span style="font-size: 0.9em;">Miss!</span>`;
             }

             showDicePopup(popupContent);
             currentRoller = buttonElement;
        }


        function getHitLocation() {
            const roll = rollSingleDie(100); // Use helper
            if (roll < 10) return "Head";
            else if (roll < 25) return "R. Arm";
            else if (roll < 40) return "L. Arm";
            else if (roll < 55) return "Chest";
            else if (roll < 70) return "Gut";
            else if (roll < 85) return "R. Leg";
            else return "L. Leg";
        }

        // --- HP and Percentage Calculation ---
        const conInput = document.getElementById('con');
        const strInput = document.getElementById('str');
        const dexInput = document.getElementById('dex');
        const strPercent = document.getElementById('str-percent');
        const dexPercent = document.getElementById('dex-percent');
        const conPercent = document.getElementById('con-percent');
        const hpMaxElements = document.querySelectorAll('.hp-max');
        const hpCurrentInputs = document.querySelectorAll('.hp-current');


        const hpTable = {
            head:    [0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7],
            arm:     [0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6],
            chest:   [0,1,2,2,2,3,3,4,4,4,5,5,5,6,6,6,7,7,8,8,8,9],
            abdomen: [0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7],
            leg:     [0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]
        };

        function calculateHp(conScore) {
            const score = Math.max(1, Math.min(21, parseInt(conScore) || 0));
            return {
                head: hpTable.head[score], arm: hpTable.arm[score], chest: hpTable.chest[score],
                abdomen: hpTable.abdomen[score], leg: hpTable.leg[score]
            };
        }

        function updateHpDisplay() {
            const conScore = conInput.value;
            const hpValues = calculateHp(conScore);
            hpMaxElements.forEach(span => {
                const location = span.dataset.location;
                if (hpValues[location] !== undefined) span.textContent = hpValues[location];
            });
            hpCurrentInputs.forEach(input => {
                const location = input.dataset.location;
                if (hpValues[location] !== undefined) {
                    const currentVal = parseInt(input.value);
                    const maxVal = hpValues[location];
                    // Reset to max only if current value is invalid or higher than new max
                    // Also check against defaultValue to handle resets correctly
                    if (isNaN(currentVal) || currentVal > maxVal || input.value === '' || input.value === input.defaultValue) {
                         input.value = maxVal;
                         // Don't set defaultValue here, let it be set by setDefaultSheetState or loading
                    }
                    input.max = maxVal;
                }
            });
             // Save is triggered by the input event listener on the CON input
        }

        // Function to get STR damage modifier string - CORRECTED LOGIC v5
        function getStrDamageModifier(strScore) {
            const score = parseInt(strScore) || 0;
            if (score <= 2) return "(-?)";
            if (score <= 6) return "(-1d6)";
            if (score <= 8) return "(-1d4)";
            if (score <= 12) return "(+0)";
            if (score <= 16) return "(+1d4)";
            if (score <= 20) return "(+2d4)";

            // CORRECTED v5: Calculate bonus dice based on thresholds of 30, 40, etc.
            let diceCount = 2; // Base for 17-20
            if (score >= 30 && score < 40) diceCount = 3;
            else if (score >= 40 && score < 50) diceCount = 4;
            else if (score >= 50 && score < 60) diceCount = 5;
            else if (score >= 60 && score < 70) diceCount = 6;
            else if (score >= 70 && score < 80) diceCount = 7;
            else if (score >= 80 && score < 90) diceCount = 8;
            else if (score >= 90 && score < 100) diceCount = 9;
            else if (score >= 100) diceCount = 10;
            // Add more steps if needed

            return `(+${diceCount}d4)`;
        }


        // Function to update all STR damage modifier displays
        function updateStrDamageModifiers() {
            const strScore = strInput.value;
            const modifierString = getStrDamageModifier(strScore);
            const modifierElements = document.querySelectorAll('.str-dmg-mod');
            modifierElements.forEach(el => {
                el.textContent = modifierString;
            });
            // Save is triggered by the input event listener on the STR input
        }

        // --- Skill Percentage Calculation ---
        /**
         * Updates the displayed percentage for a single skill based on its rank and base value.
         * @param {HTMLInputElement} rankInputElement - The rank input element for the skill.
         */
        function updateSkillPercentage(rankInputElement) {
            const entry = rankInputElement.closest('.skill-entry');
            if (!entry) return;

            const nameSpan = entry.querySelector('.skill-name-display') || entry.querySelector('.skill-name-input'); // Check input for dynamic skills
            const percentDisplay = entry.querySelector('.skill-percent-display');
            if (!nameSpan || !percentDisplay) return;

            const rank = parseInt(rankInputElement.value) || 0;
            let basePercent = parseInt(nameSpan.dataset.basePercent) || 0;
            const attribute = nameSpan.dataset.attribute; // e.g., "STR"
            const multiplier = parseInt(nameSpan.dataset.multiplier) || 1;

            // Recalculate base % if attribute-based
            if (attribute) {
                const attrInput = document.getElementById(attribute.toLowerCase());
                if (attrInput) {
                    const attrValue = parseInt(attrInput.value) || 0;
                    basePercent = attrValue * multiplier;
                }
            }

            const finalPercent = Math.min(100, basePercent + rank); // Cap at 100% for display
            percentDisplay.value = finalPercent; // Update the readonly display field

            // Also update the label for attribute-based skills to show current base
            if (attribute && nameSpan.tagName === 'SPAN') { // Only update label if it's a span (not input)
                 const baseSkillName = nameSpan.dataset.baseSkill || attribute; // Fallback to attribute name
                 const attrValue = parseInt(document.getElementById(attribute.toLowerCase())?.value || '0');
                 const currentBase = attrValue * multiplier; // Recalculate current base for label
                 nameSpan.textContent = `${baseSkillName} (${currentBase}%)`;
            }
             // Apply modifier styling if keys are pressed
             applySkillModifiers(); // Apply to ensure consistency if keys are held
             // Update XP Spent whenever a skill rank changes
             updateXpSpent();
             // Save is triggered by the input event listener on the rank input
        }

        /** Updates the base skill name for dynamically added skills when the input changes */
        function updateDynamicSkillLabel(inputElement) {
            inputElement.dataset.baseSkill = inputElement.value;
             // Update the percentage display when the name (and potentially base skill) changes
            const entry = inputElement.closest('.skill-entry');
            if (entry) {
                const rankInput = entry.querySelector('.skill-rank-input');
                if (rankInput) updateSkillPercentage(rankInput);
            }
             // Save is triggered by the input event listener on the name input
        }

        /**
         * Updates all skill percentages on the sheet. Usually called when STR/DEX changes.
         */
        function updateAllSkillPercentages() {
            document.querySelectorAll('.skill-rank-input').forEach(updateSkillPercentage);
            // Save is triggered by the input event listener on STR/DEX/CON
        }

        // --- XP Spent Calculation (UPDATED) ---
        function updateXpSpent() {
            const xpEarnedInput = document.getElementById('char-experience');
            const xpSpentInput = document.getElementById('xp-spent');
            if (!xpEarnedInput || !xpSpentInput) return;

            let totalSpent = 0;

            // Sum ranks from all skill entries (Core, Knowledge, Craft/Art, Combat Skills)
            document.querySelectorAll('.skill-rank-input').forEach(input => {
                totalSpent += parseInt(input.value) || 0;
            });

            // Sum percentage points added to weapons
            document.querySelectorAll('.weapon-entry .skill-percent-input').forEach(input => {
                totalSpent += parseInt(input.value) || 0;
            });


            xpSpentInput.value = totalSpent;

            const earned = parseInt(xpEarnedInput.value) || 0;

            // Remove previous classes
            xpSpentInput.classList.remove('xp-spent-over', 'xp-spent-equal', 'xp-spent-under');

            // Add new class based on comparison
            if (totalSpent > earned) {
                xpSpentInput.classList.add('xp-spent-over');
            } else if (totalSpent === earned) {
                xpSpentInput.classList.add('xp-spent-equal');
            } else {
                xpSpentInput.classList.add('xp-spent-under');
            }
            // Save is triggered by the input event listener on XP Earned, skill ranks, or weapon %
        }


        function updatePercentages() {
            const str = parseInt(strInput.value) || 0;
            const dex = parseInt(dexInput.value) || 0;
            const con = parseInt(conInput.value) || 0;

            // Update base characteristic percentages
            strPercent.value = `${Math.min(100, str * 5)}%`;
            dexPercent.value = `${Math.min(100, dex * 5)}%`;
            conPercent.value = `${Math.min(100, con * 5)}%`;

            // Update all skill displays that depend on attributes or ranks
            updateAllSkillPercentages();

            // Update STR damage modifiers on weapons
            updateStrDamageModifiers();

            // Apply key modifiers to characteristics as well
            applySkillModifiers();
            // Save is triggered by the input event listener on STR/DEX/CON
        }

        // --- Key Press Modifiers ---
        let isShiftPressed = false;
        let isCtrlPressed = false;

        function applySkillModifiers() {
            // Apply to Skills
            document.querySelectorAll('.skill-entry').forEach(entry => {
                const percentDisplay = entry.querySelector('.skill-percent-display');
                const rankInput = entry.querySelector('.skill-rank-input');
                const nameSpan = entry.querySelector('.skill-name-display') || entry.querySelector('.skill-name-input');
                if (!percentDisplay || !rankInput || !nameSpan) return;

                let basePercent = parseInt(nameSpan.dataset.basePercent) || 0;
                const attribute = nameSpan.dataset.attribute;
                const multiplier = parseInt(nameSpan.dataset.multiplier) || 1;
                if (attribute) {
                    const attrInput = document.getElementById(attribute.toLowerCase());
                    if (attrInput) {
                        basePercent = (parseInt(attrInput.value) || 0) * multiplier;
                    }
                }
                const rank = parseInt(rankInput.value) || 0;
                let currentPercent = basePercent + rank;

                percentDisplay.classList.remove('modifier-shift', 'modifier-ctrl');
                if (isShiftPressed) {
                    currentPercent = Math.min(100, currentPercent * 2);
                    percentDisplay.classList.add('modifier-shift');
                } else if (isCtrlPressed) {
                    currentPercent = Math.ceil(currentPercent / 2);
                    percentDisplay.classList.add('modifier-ctrl');
                }
                percentDisplay.value = currentPercent;
            });

            // Apply to Characteristics
            ['str', 'dex', 'con'].forEach(charName => {
                const percentDisplay = document.getElementById(`${charName}-percent`);
                const charInput = document.getElementById(charName);
                if (!percentDisplay || !charInput) return;

                let baseValue = parseInt(charInput.value) || 0;
                let currentPercent = Math.min(100, baseValue * 5);

                percentDisplay.classList.remove('modifier-shift', 'modifier-ctrl');
                 if (isShiftPressed) {
                    currentPercent = Math.min(100, currentPercent * 2);
                    percentDisplay.classList.add('modifier-shift');
                } else if (isCtrlPressed) {
                    currentPercent = Math.ceil(currentPercent / 2);
                    percentDisplay.classList.add('modifier-ctrl');
                }
                percentDisplay.value = `${currentPercent}%`; // Update display value with % sign
            });
        }


        document.addEventListener('keydown', (event) => {
            // Ignore if focus is inside an input/textarea to allow typing Shift/Ctrl
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                return;
            }

            let modifierChanged = false;
            if (event.key === 'Shift' && !isShiftPressed) {
                isShiftPressed = true;
                modifierChanged = true;
            }
            if (event.key === 'Control' && !isCtrlPressed) {
                isCtrlPressed = true;
                modifierChanged = true;
            }
            if (modifierChanged) {
                applySkillModifiers();
            }
        });

        document.addEventListener('keyup', (event) => {
             let modifierChanged = false;
            if (event.key === 'Shift') {
                isShiftPressed = false;
                 modifierChanged = true;
            }
            if (event.key === 'Control') {
                isCtrlPressed = false;
                 modifierChanged = true;
            }
             if (modifierChanged) {
                applySkillModifiers(); // Reapply to remove styles/reset values
            }
        });

        // Handle window losing focus, reset modifiers
        window.addEventListener('blur', () => {
            if (isShiftPressed || isCtrlPressed) {
                isShiftPressed = false;
                isCtrlPressed = false;
                applySkillModifiers();
            }
        });

        // --- Class Change Handler ---
        function handleClassChange(selectElement) {
            const xpInput = document.getElementById('char-experience');
            if (!xpInput) return;

            const selectedClass = selectElement.value;
            if (selectedClass === 'Gentleman') {
                xpInput.placeholder = "150 (100+50 Knowledge)";
            } else if (selectedClass === 'Noble') {
                xpInput.placeholder = "200 (100+100 Knowledge)";
            } else {
                xpInput.placeholder = "100"; // Default placeholder
            }
            // Save is triggered by the change event listener on the select element
        }

        // --- Export/Import Functions ---

        function gatherSheetData() {
            const data = { version: 3, sections: {} }; // Keep version consistent

            // Header
            data.header = {
                name: document.getElementById('char-name')?.value || '',
                class: document.getElementById('char-class-select')?.value || 'Commoner',
                profession: document.getElementById('char-profession')?.value || '',
                xpEarned: document.getElementById('char-experience')?.value || '0',
                goal: document.getElementById('char-goal')?.value || ''
            };

            // Characteristics
            data.characteristics = {
                str: document.getElementById('str')?.value || '0',
                dex: document.getElementById('dex')?.value || '0',
                con: document.getElementById('con')?.value || '0'
            };

            // Description & Flaws
            data.description = {
                desc: document.getElementById('char-desc')?.value || '',
                flaws: document.getElementById('char-flaws')?.value || ''
            };

            // Skills (Core, Knowledge, Craft/Art)
            data.skills = { core: [], knowledge: [], craftArt: [] };
            document.querySelectorAll('#skills-container .skill-entry').forEach(entry => {
                const nameSpan = entry.querySelector('.skill-name-display');
                const nameInput = entry.querySelector('.skill-name-input');
                const rankInput = entry.querySelector('.skill-rank-input');
                if (rankInput && (nameSpan || nameInput)) {
                    const skillData = {
                        rank: rankInput.value || '0',
                        // Use nameInput value if it exists (dynamic skill)
                        name: nameInput ? nameInput.value : undefined,
                        // Use span dataset if it exists (predefined skill)
                        baseSkill: nameSpan ? nameSpan.dataset.baseSkill : (nameInput ? nameInput.dataset.baseSkill : undefined),
                        basePercent: nameSpan ? nameSpan.dataset.basePercent : (nameInput ? nameInput.dataset.basePercent : '0'),
                        attribute: nameSpan?.dataset.attribute,
                        multiplier: nameSpan?.dataset.multiplier,
                    };
                    // Clean up undefined properties
                    Object.keys(skillData).forEach(key => skillData[key] === undefined && delete skillData[key]);
                    data.skills.core.push(skillData);
                }
            });
             document.querySelectorAll('#knowledge-container .skill-entry').forEach(entry => {
                 const nameSpan = entry.querySelector('.skill-name-display');
                 const nameInput = entry.querySelector('.skill-name-input');
                 const rankInput = entry.querySelector('.skill-rank-input');
                 if (rankInput && (nameSpan || nameInput)) {
                     const skillData = {
                         rank: rankInput.value || '0',
                         name: nameInput ? nameInput.value : undefined,
                         baseSkill: nameSpan ? nameSpan.dataset.baseSkill : (nameInput ? nameInput.dataset.baseSkill : undefined),
                         basePercent: nameSpan ? nameSpan.dataset.basePercent : (nameInput ? nameInput.dataset.basePercent : '0'),
                     };
                     Object.keys(skillData).forEach(key => skillData[key] === undefined && delete skillData[key]);
                     data.skills.knowledge.push(skillData);
                 }
             });
             document.querySelectorAll('#craft-art-container .skill-entry').forEach(entry => {
                 const nameInput = entry.querySelector('.skill-name-input'); // Always input for these
                 const rankInput = entry.querySelector('.skill-rank-input');
                 if (nameInput && rankInput) {
                     const skillData = {
                         rank: rankInput.value || '0',
                         name: nameInput.value || '', // Always has name
                         basePercent: nameInput.dataset.basePercent || '0',
                     };
                     data.skills.craftArt.push(skillData);
                 }
             });


            // Combat Details
            data.combat = { skills: [], meleeWeapons: [], rangedWeapons: [], hitLocations: {} };
             document.querySelectorAll('#combat-skills-display .skill-entry').forEach(entry => {
                 const nameSpan = entry.querySelector('.skill-name-display');
                 const nameInput = entry.querySelector('.skill-name-input');
                 const rankInput = entry.querySelector('.skill-rank-input');
                 if (rankInput && (nameSpan || nameInput)) {
                     const skillData = {
                         rank: rankInput.value || '0',
                         name: nameInput ? nameInput.value : undefined,
                         baseSkill: nameSpan ? nameSpan.dataset.baseSkill : (nameInput ? nameInput.dataset.baseSkill : undefined),
                         basePercent: nameSpan ? nameSpan.dataset.basePercent : (nameInput ? nameInput.dataset.basePercent : '0'),
                         attribute: nameSpan?.dataset.attribute,
                         multiplier: nameSpan?.dataset.multiplier,
                     };
                     Object.keys(skillData).forEach(key => skillData[key] === undefined && delete skillData[key]);
                     data.combat.skills.push(skillData);
                 }
             });
            document.querySelectorAll('#melee-weapons-container .weapon-entry').forEach(entry => {
                 data.combat.meleeWeapons.push({
                     name: entry.querySelector('textarea[placeholder="Weapon Name"]')?.value || '',
                     percent: entry.querySelector('.skill-percent-input')?.value || '0',
                     damage: entry.querySelector('.dmg-input')?.value || '',
                     notes: entry.querySelector('textarea[placeholder="Notes"]')?.value || ''
                 });
            });
             document.querySelectorAll('#ranged-weapons-container .weapon-entry').forEach(entry => {
                 data.combat.rangedWeapons.push({
                     name: entry.querySelector('textarea[placeholder="Weapon Name"]')?.value || '',
                     percent: entry.querySelector('.skill-percent-input')?.value || '0',
                     damage: entry.querySelector('.dmg-input')?.value || '',
                     notes: entry.querySelector('textarea[placeholder="Notes"]')?.value || ''
                 });
            });
            document.querySelectorAll('.hit-location').forEach(loc => {
                const locId = loc.dataset.loc;
                const apInputs = loc.querySelectorAll('.hp-ap-input'); // Gets both AP inputs
                const hpInput = loc.querySelector('.hp-current');
                if (locId && apInputs.length === 2 && hpInput) {
                    data.combat.hitLocations[locId] = {
                        apCurrent: apInputs[0].value || '0',
                        apMax: apInputs[1].value || '0',
                        hpCurrent: hpInput.value || '0'
                        // Max HP is calculated, no need to save
                    };
                }
            });

            // Inventory
            data.inventory = { backpack: [], satchel: '', coin: '0', dynamic: [] };
            document.querySelectorAll('#inventory .sub-section:first-of-type input[placeholder^="Slot"]').forEach(input => {
                data.inventory.backpack.push(input.value || '');
            });
            data.inventory.satchel = document.querySelector('#inventory textarea[placeholder="List satchel items..."]')?.value || '';
            data.inventory.coin = document.getElementById('coin')?.value || '0';
            document.querySelectorAll('#dynamic-inventory-container .dynamic-inventory-section').forEach(section => {
                const dynamicSectionData = {
                    title: section.querySelector('.section-title-text')?.textContent || '',
                    color: section.querySelector('.section-header')?.style.backgroundColor || '',
                    items: []
                };
                section.querySelectorAll('.dynamic-entry input[placeholder="Item Slot"]').forEach(itemInput => {
                     dynamicSectionData.items.push({ item: itemInput.value || '' });
                });
                data.inventory.dynamic.push(dynamicSectionData);
            });

            // Powers
            data.powers = [];
             document.querySelectorAll('#powers-container .dynamic-entry').forEach(entry => {
                 const input = entry.querySelector('input[placeholder="Power or Note"]');
                 if (input) data.powers.push({ text: input.value || '' });
             });

            // Notes
            data.notes = document.querySelector('#notes-container textarea')?.value || '';

            // Section Customizations (Titles & Colors)
             data.sectionCustomizations = {};
             document.querySelectorAll('.styled-section[data-section-id]').forEach(section => {
                 const sectionId = section.dataset.sectionId;
                 const titleText = section.querySelector('.section-title-text');
                 const header = section.querySelector('.section-header');
                 if (sectionId && titleText && header) {
                     // Only save customization if title or color differs from default
                     const defaultTitle = section.querySelector('.section-title-input')?.getAttribute('value'); // Get original default value
                     const defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--default-section-bg').trim();
                     const currentTitle = titleText.textContent;
                     const currentColor = header.style.backgroundColor; // Gets inline style

                     let customization = {};
                     let hasCustomization = false;

                     if (defaultTitle && currentTitle !== defaultTitle) {
                         customization.title = currentTitle;
                         hasCustomization = true;
                     }
                     // Check if color is set and different from the default CSS variable
                     // Need to convert RGB to hex for comparison if necessary, or compare against known default
                     // For simplicity, only save if a background color style is explicitly set
                     if (currentColor && currentColor !== defaultColor) {
                         customization.color = currentColor;
                         hasCustomization = true;
                     }

                     if (hasCustomization) {
                         data.sectionCustomizations[sectionId] = customization;
                     }
                 }
             });


            return data;
        }

        function exportSheetData() {
            try {
                const sheetData = gatherSheetData();
                const jsonData = JSON.stringify(sheetData, null, 2); // Pretty print JSON
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const charName = document.getElementById('char-name')?.value || 'character';
                const filename = `${charName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_winedark_sheet.json`;

                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                showDicePopup("Sheet data exported successfully!"); // Simple feedback
            } catch (error) {
                console.error("Error exporting sheet data:", error);
                showDicePopup("Error exporting sheet data. See console for details.");
            }
        }

        function importSheetData(event) {
            const file = event.target.files[0];
            if (!file) {
                return; // No file selected
            }

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const jsonData = e.target.result;
                    const data = JSON.parse(jsonData);

                    // --- Basic Validation ---
                    if (typeof data !== 'object' || data === null || !data.version) {
                         throw new Error("Invalid file format.");
                    }
                    // Add more specific validation based on your data structure if needed

                    // Reset the sheet before populating to ensure clean slate
                    setDefaultSheetState(false); // Pass false to skip recalc during reset
                    populateSheetData(data);
                    // Recalculate everything *after* populating
                    updateHpDisplay();
                    updatePercentages();
                    updateXpSpent();
                    saveSheetToLocalStorage(); // Save the imported data immediately
                    showDicePopup("Sheet data imported successfully!");

                } catch (error) {
                    console.error("Error importing sheet data:", error);
                    showDicePopup(`Error importing file: ${error.message}`);
                } finally {
                     // Reset file input to allow importing the same file again if needed
                     event.target.value = null;
                }
            };

            reader.onerror = function(e) {
                 console.error("Error reading file:", e);
                 showDicePopup("Error reading file.");
                 event.target.value = null; // Reset file input
            };

            reader.readAsText(file);
        }

        function populateSheetData(data) {
             // --- Populate Header ---
             if (data.header) {
                document.getElementById('char-name').value = data.header.name || '';
                document.getElementById('char-class-select').value = data.header.class || 'Commoner';
                handleClassChange(document.getElementById('char-class-select')); // Update placeholder
                document.getElementById('char-profession').value = data.header.profession || '';
                document.getElementById('char-experience').value = data.header.xpEarned || '0';
                document.getElementById('char-goal').value = data.header.goal || '';
             }

             // --- Populate Characteristics ---
             if (data.characteristics) {
                 document.getElementById('str').value = data.characteristics.str || '0';
                 document.getElementById('dex').value = data.characteristics.dex || '0';
                 document.getElementById('con').value = data.characteristics.con || '0';
             }

             // --- Populate Description & Flaws ---
             if (data.description) {
                 document.getElementById('char-desc').value = data.description.desc || '';
                 document.getElementById('char-flaws').value = data.description.flaws || '';
                 autoExpandTextarea(document.getElementById('char-desc'));
                 autoExpandTextarea(document.getElementById('char-flaws'));
             }

             // --- Populate Skills ---
             if (data.skills) {
                 // Core Skills: Add defaults first, then add any extras found in saved data
                 const populatedCoreBaseSkills = new Set();
                 defaultSheetStructure.skills.core.forEach(skillDef => {
                     const savedSkill = data.skills.core?.find(s => s.baseSkill === skillDef.baseSkill);
                     addEntry('skills-container', skillTemplate, { ...skillDef, rank: savedSkill?.rank || '0' });
                     populatedCoreBaseSkills.add(skillDef.baseSkill);
                 });
                 data.skills.core?.filter(s => s.name && !populatedCoreBaseSkills.has(s.name)) // Find dynamic skills (saved with 'name', not already added)
                     .forEach(skillData => addEntry('skills-container', skillTemplate, skillData));

                 // Knowledge Skills: Add defaults first, then extras
                 const populatedKnowledgeBaseSkills = new Set();
                 defaultSheetStructure.skills.knowledge.forEach(skillDef => {
                     const savedSkill = data.skills.knowledge?.find(s => s.baseSkill === skillDef.baseSkill);
                     addEntry('knowledge-container', knowledgeTemplate, { ...skillDef, name: skillDef.baseSkill, rank: savedSkill?.rank || '0' });
                      populatedKnowledgeBaseSkills.add(skillDef.baseSkill);
                 });
                 data.skills.knowledge?.filter(s => s.name && !populatedKnowledgeBaseSkills.has(s.name))
                     .forEach(skillData => addEntry('knowledge-container', knowledgeTemplate, skillData));

                 // Craft/Art Skills (Always dynamic)
                 data.skills.craftArt?.forEach(skillData => addEntry('craft-art-container', craftArtTemplate, skillData));
             }


             // --- Populate Combat Details ---
             if (data.combat) {
                 // Combat Skills: Add defaults first, then extras
                 const populatedCombatBaseSkills = new Set();
                 defaultSheetStructure.combat.skills.forEach(skillDef => {
                     const savedSkill = data.combat.skills?.find(s => s.baseSkill === skillDef.baseSkill);
                     addEntry('combat-skills-display', combatStatTemplate, { ...skillDef, name: skillDef.baseSkill, rank: savedSkill?.rank || '0' });
                     populatedCombatBaseSkills.add(skillDef.baseSkill);
                 });
                 data.combat.skills?.filter(s => s.name && !populatedCombatBaseSkills.has(s.name))
                     .forEach(skillData => addEntry('combat-skills-display', combatStatTemplate, skillData));


                 // Weapons
                 data.combat.meleeWeapons?.forEach(weaponData => addEntry('melee-weapons-container', meleeWeaponTemplate, weaponData));
                 data.combat.rangedWeapons?.forEach(weaponData => addEntry('ranged-weapons-container', rangedWeaponTemplate, weaponData));

                 // Hit Locations
                 if (data.combat.hitLocations) {
                     Object.keys(data.combat.hitLocations).forEach(locId => {
                         const locElement = document.querySelector(`.hit-location[data-loc="${locId}"]`);
                         const locData = data.combat.hitLocations[locId];
                         if (locElement && locData) {
                             const apInputs = locElement.querySelectorAll('.hp-ap-input');
                             const hpInput = locElement.querySelector('.hp-current');
                             if (apInputs.length === 2 && hpInput) {
                                 apInputs[0].value = locData.apCurrent || '0';
                                 apInputs[1].value = locData.apMax || '0';
                                 hpInput.value = locData.hpCurrent || '0';
                             }
                         }
                     });
                 }
             }

             // --- Populate Inventory ---
             if (data.inventory) {
                 const backpackInputs = document.querySelectorAll('#inventory .sub-section:first-of-type input[placeholder^="Slot"]');
                 data.inventory.backpack?.forEach((item, index) => {
                     if (backpackInputs[index]) backpackInputs[index].value = item || '';
                 });
                 document.querySelector('#inventory textarea[placeholder="List satchel items..."]').value = data.inventory.satchel || '';
                 document.getElementById('coin').value = data.inventory.coin || '0';
                 data.inventory.dynamic?.forEach(sectionData => addInventorySection(sectionData));
             }

             // --- Populate Powers ---
             data.powers?.forEach(powerData => addEntry('powers-container', powerTemplate, powerData));

             // --- Populate Notes ---
             document.querySelector('#notes-container textarea').value = data.notes || '';
             autoExpandTextarea(document.querySelector('#notes-container textarea'));

             // --- Populate Section Customizations ---
             if (data.sectionCustomizations) {
                 Object.keys(data.sectionCustomizations).forEach(sectionId => {
                     const section = document.querySelector(`.styled-section[data-section-id="${sectionId}"]`);
                     const customData = data.sectionCustomizations[sectionId];
                     if (section && customData) {
                         const titleText = section.querySelector('.section-title-text');
                         const titleInput = section.querySelector('.section-title-input');
                         const header = section.querySelector('.section-header');
                         const colorInput = section.querySelector('.color-picker-input'); // Find color input

                         if (titleText && customData.title) titleText.textContent = customData.title;
                         if (titleInput && customData.title) titleInput.value = customData.title; // Keep input synced
                         if (header && customData.color) header.style.backgroundColor = customData.color;
                         if (colorInput && customData.color) colorInput.value = customData.color; // Update color picker value
                     }
                 });
             }

             // --- Recalculations are now done *after* populateSheetData in the calling function (load/import) ---
        }

        // --- Reset Character Sheet Function ---
        function resetCharacterSheet() {
            const confirmed = confirm("Warning: Creating a new character will delete the current one from this browser. Export your character first if you want to save it permanently. Continue?");
            if (confirmed) {
                localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear saved data
                setDefaultSheetState(); // Reset to defaults and recalculate
                showDicePopup("Character sheet reset.");
            }
        }

        // --- Set Default Sheet State ---
        function setDefaultSheetState(updateCalculations = true) {
            // Clear dynamic entries first
            document.getElementById('skills-container').innerHTML = '';
            document.getElementById('knowledge-container').innerHTML = '';
            document.getElementById('craft-art-container').innerHTML = '';
            document.getElementById('combat-skills-display').innerHTML = '';
            document.getElementById('melee-weapons-container').innerHTML = '';
            document.getElementById('ranged-weapons-container').innerHTML = '';
            document.getElementById('powers-container').innerHTML = '';
            document.getElementById('dynamic-inventory-container').innerHTML = '';
            document.getElementById('dynamic-stats-container').innerHTML = ''; // Clear dynamic characteristics if any

            // Reset Header
            document.getElementById('char-name').value = '';
            document.getElementById('char-class-select').value = 'Commoner';
            handleClassChange(document.getElementById('char-class-select'));
            document.getElementById('char-profession').value = '';
            document.getElementById('char-experience').value = '0';
            document.getElementById('char-goal').value = '';

            // Reset Characteristics
            document.getElementById('str').value = '0';
            document.getElementById('dex').value = '0';
            document.getElementById('con').value = '0';

            // Reset Description & Flaws
            document.getElementById('char-desc').value = '';
            document.getElementById('char-flaws').value = '';
            autoExpandTextarea(document.getElementById('char-desc'));
            autoExpandTextarea(document.getElementById('char-flaws'));

            // Reset Skills (populate defaults using addEntry to ensure consistency)
            defaultSheetStructure.skills.core.forEach(skillDef => addEntry('skills-container', skillTemplate, skillDef));
            defaultSheetStructure.skills.knowledge.forEach(skillDef => addEntry('knowledge-container', knowledgeTemplate, { ...skillDef, name: skillDef.baseSkill })); // Pass name for label

            // Reset Combat Skills (populate defaults)
            defaultSheetStructure.combat.skills.forEach(skillDef => addEntry('combat-skills-display', combatStatTemplate, { ...skillDef, name: skillDef.baseSkill })); // Pass name for label

            // Reset Hit Locations (AP/HP)
            document.querySelectorAll('.hit-location').forEach(loc => {
                const apInputs = loc.querySelectorAll('.hp-ap-input');
                const hpInput = loc.querySelector('.hp-current');
                if (apInputs.length === 2) {
                    apInputs[0].value = '0'; // Current AP
                    apInputs[1].value = '0'; // Max AP
                }
                if (hpInput) {
                    hpInput.value = '0'; // Current HP (Max HP will be set by updateHpDisplay)
                    hpInput.defaultValue = '0'; // Set default value for comparison in updateHpDisplay
                }
            });

            // Reset Inventory
            document.querySelectorAll('#inventory .sub-section:first-of-type input[placeholder^="Slot"]').forEach(input => input.value = '');
            document.querySelector('#inventory textarea[placeholder="List satchel items..."]').value = '';
            document.getElementById('coin').value = '10'; // Default coin

            // Reset Notes
            document.querySelector('#notes-container textarea').value = '';
            autoExpandTextarea(document.querySelector('#notes-container textarea'));

            // Reset Section Customizations (Titles & Colors)
            const defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--default-section-bg').trim();
            document.querySelectorAll('.styled-section[data-section-id]').forEach(section => {
                 const titleText = section.querySelector('.section-title-text');
                 const titleInput = section.querySelector('.section-title-input');
                 const header = section.querySelector('.section-header');
                 const colorInput = section.querySelector('.color-picker-input');
                 const defaultTitle = titleInput?.getAttribute('value'); // Get original value attribute

                 if (titleText && defaultTitle) titleText.textContent = defaultTitle;
                 if (titleInput && defaultTitle) titleInput.value = defaultTitle;
                 if (header) header.style.backgroundColor = ''; // Reset inline style to use CSS default
                 if (colorInput) colorInput.value = defaultColor; // Reset color picker too
            });

            // Recalculate derived values if requested
            if (updateCalculations) {
                updateHpDisplay();
                updatePercentages();
                updateXpSpent();
            }
             // No save needed here, as this is called during reset (which clears storage) or load (which happens before user changes)
        }


        // --- Initial Setup on Page Load ---
        document.addEventListener('DOMContentLoaded', () => {
            // Load saved data or set defaults. Calculations happen inside loadSheetFromLocalStorage if successful, or after setting default state.
            loadSheetFromLocalStorage();

            // Add event listener to the main container for inputs/changes to trigger debounced save
            const sheetContainer = document.getElementById('character-sheet-container');
            if (sheetContainer) {
                sheetContainer.addEventListener('input', (event) => {
                    // Check if the event target is an input, textarea, or select
                    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName)) {
                        // console.log('Input event triggered save for:', event.target.id || event.target.placeholder); // DEBUGGING
                        debouncedSave();
                    }
                });
                 // Add listener for 'change' specifically for color inputs
                 sheetContainer.addEventListener('change', (event) => {
                     if (event.target.type === 'color') {
                        // console.log('Change event triggered save for color picker'); // DEBUGGING
                         debouncedSave();
                     }
                 });
            }


            // Initialize auto-expand for any existing textareas (important after loading data)
            document.querySelectorAll('textarea.auto-expand').forEach(autoExpandTextarea);

             // Add click listener to dice popup
             dicePopup.addEventListener('click', () => {
                 dicePopup.style.display = 'none';
                 currentRoller = null;
             });

            // Initial Class check to set placeholder (already done by load/reset)
        });

    </script>

</body>
</html>


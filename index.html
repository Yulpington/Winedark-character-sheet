<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wine-Dark Character Sheet</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üç∑</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        :root {
            --default-section-bg: #580b20; /* Default header background color */
            --grid-gap: 1rem; /* Reduced gap for tighter layout */
            --grid-columns: 12;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0;
            color: #333;
            padding: 1rem;
        }
        .character-sheet {
            max-width: 1000px;
            margin: auto;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: var(--grid-gap);
            display: grid;
            grid-template-columns: repeat(var(--grid-columns), 1fr);
            gap: var(--grid-gap);
            position: relative; /* Needed for absolute positioning context */
        }

        /* --- Sheet Actions Container (Top Right) --- */
        #sheet-actions-container {
            position: absolute;
            top: calc(var(--grid-gap) * 0.5); /* Adjust as needed */
            right: calc(var(--grid-gap) * 0.5); /* Adjust as needed */
            z-index: 10; /* Ensure it's above section headers */
            display: flex;
            gap: 0.5rem;
            background-color: rgba(255, 255, 255, 0.8); /* Slight background */
            padding: 0.5rem;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        /* Style buttons within the sheet actions container */
        #sheet-actions-container .action-btn {
             background-color: #6b7280; /* Gray background */
             color: white;
             border: 1px solid #4b5563;
             padding: 0.3rem 0.6rem; /* Adjust padding */
             font-size: 0.9rem;
             border-radius: 4px; /* Added rounded corners */
             transition: background-color 0.2s; /* Added transition */
        }
         #sheet-actions-container .action-btn:hover {
             background-color: #4b5563; /* Darker gray on hover */
         }
         #sheet-actions-container .new-char-btn {
             background-color: #ef4444; /* Red background */
             border-color: #dc2626;
         }
         #sheet-actions-container .new-char-btn:hover {
             background-color: #dc2626; /* Darker red on hover */
         }


        /* --- Section Styling --- */
        .styled-section {
            margin-bottom: 0; /* Grid gap handles spacing */
            border-radius: 6px;
            overflow: hidden; /* Ensures content stays within rounded borders */
            border: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            min-height: 150px; /* Minimum height for sections */
            position: relative; /* For absolute positioned elements inside */
            background-color: #f9f9f9; /* Light background for section content area */
            resize: none; /* Prevent user resizing */
        }
        .section-header {
            background-color: var(--default-section-bg);
            color: white;
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 40px; /* Ensure header has consistent height */
            user-select: none; /* Prevent text selection in header */
            cursor: default; /* Default cursor for header */
        }
        .section-title-container { display: flex; align-items: center; gap: 0.5rem; flex-grow: 1; cursor: default; }
        .section-title-text { font-weight: bold; font-size: 1.1rem; }
        /* Smaller title for dynamic inventory */
        .dynamic-inventory-section .section-title-text { font-size: 1rem; }
        .section-title-input {
            font-weight: bold; font-size: 1.1rem; border: none;
            background-color: rgba(255, 255, 255, 0.2); color: white;
            padding: 0.2rem 0.4rem; border-radius: 3px; outline: none;
            display: none; /* Hidden by default */
            width: auto; min-width: 150px;
        }
        .dynamic-inventory-section .section-title-input { font-size: 1rem; }
         /* Toggle visibility when editing title */
         .section-title-container.editing .section-title-text,
         .section-title-container.editing .edit-title-btn { display: none; }
         .section-title-container.editing .section-title-input { display: inline-block; }

        .section-actions { display: flex; align-items: center; gap: 0.5rem; position: relative; }
        .section-content { padding: 1rem; border-top: none; flex-grow: 1; overflow-y: auto; }
        .section-footer { padding: 0.5rem 1rem; text-align: center; border-top: 1px solid #eee; }

        /* Action Buttons Styling (for section headers) */
        .action-btn { /* Buttons in header */
            background: none; border: 1px solid rgba(255, 255, 255, 0.5); color: white;
            cursor: pointer; font-size: 1rem; line-height: 1; padding: 0.25rem 0.4rem; /* Default padding */
            border-radius: 4px; transition: background-color 0.2s, color 0.2s; font-weight: bold;
            display: inline-flex; /* Ensure flex alignment works */
            align-items: center;
            justify-content: center;
        }
        .action-btn:hover { background-color: rgba(255, 255, 255, 0.2); }
         .edit-title-btn { font-size: 0.9rem; padding: 0.1rem 0.3rem; } /* Smaller padding for edit */
         .delete-mode-btn {
             font-size: 1rem;
             padding: 0.4rem 0.6rem; /* Increased padding */
         }
         .delete-mode-btn.active { background-color: rgba(255, 80, 80, 0.3); border-color: rgba(255, 80, 80, 0.7); }

         /* Color Picker Positioning */
         .color-picker-btn { /* Class added to the color button's wrapper */
             position: relative; /* Make it a positioning context */
             display: inline-flex; /* Align icon properly */
             align-items: center;
             justify-content: center;
         }
         .color-picker-input {
             opacity: 0; /* Hidden visually */
             width: 100%; height: 100%; /* Cover the button */
             position: absolute;
             left: 0; /* Align with button */
             top: 0;  /* Align with button */
             cursor: pointer; border: none; padding: 0;
             z-index: 1; /* Ensure it's clickable on top */
         }

         .add-entry-footer-btn { /* Green '+' button below content */
            background-color: #10b981; color: white; border: none; border-radius: 50%;
            width: 28px; height: 28px; font-size: 1.2rem; font-weight: bold;
            line-height: 28px; cursor: pointer; transition: background-color 0.2s;
            display: inline-flex; align-items: center; justify-content: center;
         }
         .add-entry-footer-btn:hover { background-color: #059669; }
         .delete-section-btn { /* Red 'X' button for dynamic sections */
             background: none; border: none; color: #ef4444;
             font-size: 1.3rem; /* Slightly larger X */
             cursor: pointer;
             padding: 0.4rem; /* Increased padding */
             line-height: 1; font-weight: bold;
             /* Visibility controlled by delete mode */
             opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s;
             display: inline-flex; /* Ensure alignment */
             align-items: center;
             justify-content: center;
         }
         .delete-mode-active .delete-section-btn {
             opacity: 1; visibility: visible;
         }
         .delete-section-btn:hover { color: #dc2626; }


        /* --- Grid Layout Spans (NEW INTUITIVE LAYOUT) --- */
        /* Row 1: Core Identity */
        .styled-section[data-section-id="header"] { grid-column: span 8; grid-row: 1; }
        .styled-section[data-section-id="characteristics"] { grid-column: span 4; grid-row: 1; }
        /* Row 2: Combat & Skills */
        .styled-section[data-section-id="combat-details"] { grid-column: span 8; grid-row: 2; }
        .styled-section[data-section-id="skills"] { grid-column: span 4; grid-row: 2; }
        /* Row 3: Inventory & Description */
        .styled-section[data-section-id="inventory"] { grid-column: span 4; grid-row: 3; }
        .styled-section[data-section-id="description"] { grid-column: span 8; grid-row: 3; }
        /* Row 4: Powers & Notes */
        .styled-section[data-section-id="powers"] { grid-column: span 4; grid-row: 4; }
        .styled-section[data-section-id="notes"] { grid-column: span 8; grid-row: 4; }

        /* Dynamic inventory sections still take full width when added */
        .dynamic-inventory-section { grid-column: span 12; }


        /* Input styling */
        input[type="text"], input[type="number"], textarea, select { /* Added select */
            width: 100%; padding: 0.3rem 0.5rem; border: 1px solid #ccc;
            border-radius: 4px; box-sizing: border-box; font-size: 0.9rem; margin-bottom: 0.25rem;
            background-color: white; /* Ensure select background is white */
        }
        /* Style specifically for readonly number inputs to look like text */
        input[type="number"][readonly].percent-display,
        input[type="text"][readonly].percent-display {
             -moz-appearance: textfield; /* Firefox */
             appearance: textfield;
             background-color: #e5e7eb; /* Gray background */
             cursor: default;
             border: 1px solid #d1d5db;
             color: #4b5563;
        }
        input[type="number"][readonly].percent-display::-webkit-outer-spin-button,
        input[type="number"][readonly].percent-display::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        select {
             appearance: none; /* Remove default arrow */
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%236b7280'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E"); /* Tailwind UI arrow */
             background-repeat: no-repeat;
             background-position: right 0.5rem center;
             background-size: 1.25em 1.25em;
             padding-right: 2.5rem; /* Make space for arrow */
        }
        textarea.auto-expand {
            line-height: 1.4; min-height: calc(1.4em + 0.6rem + 2px); /* Base height */
            height: calc(1.4em + 0.6rem + 2px); /* Initial height */
            resize: none; overflow: hidden; /* Hide scrollbar, resize handled by JS */
            white-space: normal; overflow-wrap: break-word; word-wrap: break-word; /* Ensure text wraps */
        }
        input[type="number"] { -moz-appearance: textfield; } /* Remove spinners in Firefox */
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; } /* Remove spinners in Chrome/Safari */
        label { display: block; margin-bottom: 0.25rem; font-size: 0.9rem; font-weight: 500; }

        /* Dynamic Entry Styling */
        .dynamic-entry { display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; }
        .dynamic-entry input, .dynamic-entry textarea { margin-bottom: 0; }
        /* Reduce width of text input in skills for better spacing */
        .dynamic-entry .skill-name-input { flex-grow: 1; width: auto; min-width: 80px; }
        /* Class for skill name display spans */
        .skill-name-display {
            flex-grow: 1; /* Allow skill name to take up space */
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: auto; /* Push rank/percent to right */
            padding-right: 0.5rem; /* Space before rank */
        }
        .remove-btn { /* Red minus button next to entries */
            background: none; border: none; cursor: pointer; font-size: 1.1rem; line-height: 1;
            padding: 0.2rem; color: #ef4444; transition: color 0.2s, opacity 0.2s, visibility 0.2s, width 0.2s, margin 0.2s, padding 0.2s; font-weight: bold;
            margin-right: 0.5rem; flex-shrink: 0;
            /* Hidden by default, shown in delete mode */
            opacity: 0; visibility: hidden; width: 0; margin-right: 0; padding: 0;
        }
        .delete-mode-active .remove-btn {
            opacity: 1; visibility: visible; width: auto; margin-right: 0.5rem; padding: 0.2rem;
        }
        .remove-btn:hover { color: #dc2626; }

        /* Skill Entry Specific Styling */
        .skill-entry { /* New class for skill entries */
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Consistent gap */
        }
        .skill-rank-input {
            width: 3rem !important; /* Fixed width for rank */
            text-align: center;
            flex-shrink: 0; /* Prevent shrinking */
        }
        /* Common styling for read-only percentage displays */
        .percent-display {
            text-align: center;
            background-color: #e5e7eb; /* Gray background */
            border: 1px solid #d1d5db;
            color: #4b5563; /* Darker gray text */
            cursor: default; /* Indicate non-editable */
            padding: 0.3rem 0.5rem; /* Match input padding */
            border-radius: 4px; /* Match input radius */
            font-size: 0.9rem; /* Match input font size */
            transition: background-color 0.1s ease-in-out, color 0.1s ease-in-out; /* Smooth transition for modifiers */
            flex-shrink: 0; /* Prevent shrinking */
            box-sizing: border-box; /* Include padding/border in width */
        }
        .skill-percent-display {
            width: 4rem !important; /* Fixed width for skill percentage display */
        }
        .characteristic-entry .percent-display {
             width: 100%; /* Make char percent take available space */
        }

        /* Modifier Styling for Percentage Displays */
        .percent-display.modifier-shift {
            background-color: #dcfce7 !important; /* Light green - Use !important to override base gray */
            color: #166534 !important; /* Dark green */
            font-weight: bold;
        }
        .percent-display.modifier-ctrl {
            background-color: #fee2e2 !important; /* Light red - Use !important to override base gray */
            color: #991b1b !important; /* Dark red */
            font-weight: bold;
        }


        /* Specific Layouts */
         /* Weapon entry grid layout - Added column for STR Mod */
         .weapon-entry {
             display: grid;
             /* Columns: RemoveBtn | Weapon Name | % Input | Damage Input | STR Mod | Notes | Roll Btn */
             grid-template-columns: auto 3fr 1fr 2fr auto 4fr auto;
             gap: 0.5rem; align-items: start; margin-bottom: 0.5rem;
         }
         .weapon-entry input, .weapon-entry textarea { margin-bottom: 0; }
         /* Header for weapon list - Added column for STR Mod */
         .weapon-header {
             display: grid;
             grid-template-columns: auto 3fr 1fr 2fr auto 4fr auto; /* Match entry columns */
             gap: 0.5rem; font-weight: bold; font-size: 0.8rem; margin-bottom: 0.25rem; color: #555;
             padding-left: 0;
         }
         /* Adjust header padding when delete buttons are visible */
         .delete-mode-active .weapon-header { padding-left: calc(20px + 0.5rem); } /* Match remove-btn width + gap */
         /* Weapon skill % input */
         .weapon-entry .skill-percent-input {
             width: 4rem !important; /* Fixed width like skill % display */
             text-align: center;
             flex-shrink: 0;
         }

         /* STR Damage Modifier Display */
         .str-dmg-mod {
             font-size: 0.8rem;
             color: #666;
             text-align: center;
             white-space: nowrap;
             padding-top: 0.3rem; /* Align vertically roughly with input */
             align-self: center; /* Center vertically in grid cell */
         }


         /* Grid for top header fields - Adjusted for Goal moving out */
         .header-fields-grid {
             display: grid;
             /* Columns: Name(3), Class(2), Profession(2), XP Earned(2), XP Spent(1) */
             grid-template-columns: 3fr 2fr 2fr 2fr 1fr;
             gap: 1rem;
             align-items: end; /* Align items to the bottom of the cell */
             margin-bottom: 1rem; /* Add space before Goal */
         }
         .header-fields-grid > div { /* Target direct children divs */
             margin-bottom: 0; /* Remove default margin from inputs inside */
         }
         #goal-container { /* Style the container for Goal */
             margin-top: 0; /* Remove potential top margin */
         }
         /* Styling for XP Spent field */
         #xp-spent {
             background-color: #e5e7eb; /* Light gray background */
             cursor: default;
             text-align: center;
             font-weight: bold;
             transition: color 0.2s ease-in-out; /* Smooth color transition */
         }
         .xp-spent-over { color: #dc2626; } /* Red */
         .xp-spent-equal { color: #16a34a; } /* Green */
         .xp-spent-under { color: #6b7280; } /* Gray */

          /* Responsive Header Grid */
         @media (max-width: 850px) { /* Adjust breakpoint as needed */
             .header-fields-grid {
                 grid-template-columns: 1fr 1fr 1fr; /* 3 columns */
             }
             .header-fields-grid > div:nth-child(1) { grid-column: 1 / -1; } /* Name full width */
             /* Class, Profession, XP Earned, XP Spent take one column each */
         }
         @media (max-width: 600px) {
              .header-fields-grid {
                 grid-template-columns: 1fr 1fr; /* 2 columns */
             }
              .header-fields-grid > div:nth-child(1) { grid-column: 1 / -1; } /* Name full width */
              /* Goal is already outside the grid */
         }


         /* Grid for description/flaws textareas */
         .description-fields-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
         /* Flex layout for combat skills */
         .combat-skills-grid { display: flex; justify-content: space-around; gap: 0.5rem; flex-wrap: wrap; }
         .combat-skills-grid .dynamic-entry { flex-basis: auto; border: 1px solid #eee; padding: 0.5rem; border-radius: 4px; background-color: #fff; min-width: 200px; /* Increased min-width slightly */ }
         /* Adjust width of combat skill text input */
         .combat-skills-grid .dynamic-entry input[type="text"] { width: 80px; flex-grow: 0; }

        /* Characteristics Styling */
        .characteristic-entry { /* Class for STR/DEX/CON rows */
             display: grid;
             /* Label | Input | % Display | Dice Btn */
             grid-template-columns: auto minmax(0, 1fr) minmax(0, 1fr) auto;
             gap: 0.5rem;
             align-items: center;
             margin-bottom: 0.5rem;
        }
        .characteristic-entry label { margin-bottom: 0; }
        .characteristic-entry input[type=number] { margin-bottom: 0; }
        /* .characteristic-entry .percent-display class handles styling */


        /* Hit Location Specific Styling */
        .hit-location-content {
            position: relative; width: 100%; aspect-ratio: 1 / 1; /* Maintain square aspect ratio */
            /* --- UPDATED: Reverted background image URL --- */
            background-image: url('https://iili.io/3w2E1Uu.png'); /* Silhouette image */
            background-color: #ddd; /* Fallback color */
            background-size: contain; background-repeat: no-repeat; background-position: center;
            overflow: hidden; border-radius: 4px;
        }
        .hit-location {
            position: absolute; border: 1px solid #aaa; padding: 0.3rem; border-radius: 4px;
            text-align: center; font-size: 0.75rem; background-color: rgba(255, 255, 255, 0.75); /* Semi-transparent background */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); width: 18%; min-width: 60px; line-height: 1.2;
            display: flex; /* Use flexbox for vertical layout */
            flex-direction: column; /* Stack children vertically */
            gap: 0.1rem; /* Space between elements */
        }
        .hit-location label { font-weight: bold; display: block; margin-bottom: 0.1rem; font-size: 0.7rem; }
        .hp-ap-input { width: 30px; text-align: center; margin: 0 1px; font-size: 0.7rem; padding: 0.1rem; }
        .stat-line { display: flex; align-items: center; justify-content: center; gap: 0.1rem; /* Removed margin-bottom */ }
        .stat-line label { margin-bottom: 0; font-weight: normal; font-size: 0.7rem; }
        .stat-line span { font-size: 0.7rem; }
        /* Style for the new item input */
        .hit-location-item-input {
            width: 100%; /* Take full width */
            font-size: 0.7rem;
            padding: 0.1rem 0.2rem; /* Adjust padding */
            margin-top: 0.1rem; /* Space above item input */
            box-sizing: border-box; /* Include padding in width */
        }

        /* Positioning for hit location boxes */
        .hit-location[data-loc="head"] { top: 3%; left: 41%; }
        .hit-location[data-loc="chest"] { top: 25%; left: 41%; }
        .hit-location[data-loc="gut"] { top: 48%; left: 41%; } /* Adjusted */
        .hit-location[data-loc="l-arm"] { top: 28%; left: 15%; }
        .hit-location[data-loc="r-arm"] { top: 28%; right: 15%; }
        .hit-location[data-loc="l-leg"] { bottom: 5%; left: 28%; }
        .hit-location[data-loc="r-leg"] { bottom: 5%; right: 28%; }


        textarea { min-height: 60px; resize: vertical; } /* Allow vertical resize for textareas */

        /* Dice Roller Styles */
        .dice-roller-btn { cursor: pointer; font-size: 1rem; margin-left: 0.5rem; background: none; border: none; padding: 0; color: #555; flex-shrink: 0; }
        .dice-roller-btn:hover { color: #000; }
        #dice-result-popup {
            position: fixed; bottom: 20px; right: 20px; background-color: rgba(0, 0, 0, 0.8);
            color: white; padding: 10px 15px; border-radius: 5px; font-size: 1.2rem;
            z-index: 1001; display: none; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            white-space: pre-line; /* Allow line breaks */
            cursor: pointer; /* Indicate it's clickable to dismiss */
        }
        /* Style for special results in popup */
        .special-roll-text { font-weight: bold; color: #facc15; /* Yellow color */ margin-left: 0.5rem; }
        .critical-roll-text { font-weight: bold; color: #60a5fa; /* Blue color */ margin-left: 0.5rem; }
        .fumble-roll-text { font-weight: bold; color: #f87171; /* Red color */ margin-left: 0.5rem; }


        /* Responsive adjustments */
        @media (max-width: 900px) {
             .styled-section { grid-column: span 12 !important; } /* Stack all sections on medium screens */
             .hit-location { width: 22%; font-size: 0.7rem; }
             .hp-ap-input { width: 25px; }
             .description-fields-grid { grid-template-columns: 1fr; } /* Stack desc/flaws */
             /* Adjust top-right actions position */
             #sheet-actions-container { top: 0.2rem; right: 0.2rem; padding: 0.3rem; }
             #sheet-actions-container .action-btn { font-size: 0.8rem; padding: 0.2rem 0.4rem; }
        }
        @media (max-width: 600px) {
             /* Adjust weapon grid for smaller screens */
             .weapon-entry, .weapon-header {
                 grid-template-columns: auto 2fr 1fr 1fr auto 2fr auto; /* Adjust columns */
             }
             .hit-location-content { aspect-ratio: 2 / 3; } /* Adjust aspect ratio for taller screens */
             .hit-location { width: 28%; font-size: 0.65rem; padding: 0.2rem; }
             .hp-ap-input { width: 22px; }
             /* Adjust hit location positions for smaller screens */
             .hit-location[data-loc="l-arm"] { top: 25%; left: 5%; }
             .hit-location[data-loc="r-arm"] { top: 25%; right: 5%; }
             .hit-location[data-loc="l-leg"] { bottom: 3%; left: 15%; }
             .hit-location[data-loc="r-leg"] { bottom: 3%; right: 15%; }
             .skill-entry { flex-wrap: wrap; } /* Allow skill elements to wrap on small screens */
             .skill-name-display { width: 100%; margin-right: 0; margin-bottom: 0.25rem; } /* Skill name full width */
             .characteristic-entry { grid-template-columns: auto 1fr 1fr auto; } /* Adjust characteristic layout */
             .hit-location-item-input { font-size: 0.6rem; } /* Smaller item input font on small screens */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>

    <div class="character-sheet" id="character-sheet-container">

        <div id="sheet-actions-container">
            <button class="action-btn new-char-btn" onclick="resetCharacterSheet()" title="Start New Character">‚ú® New</button>
            <button class="action-btn" onclick="exportSheetData()" title="Export Sheet Data">üì§ Export</button>
            <button class="action-btn" onclick="document.getElementById('import-file-input').click()" title="Import Sheet Data">üì• Import</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="importSheetData(event)">
        </div>

        <div class="styled-section" data-section-id="header" data-deletable="false">
            <div class="section-header">
                <div class="section-title-container">
                    <span class="section-title-text">Wine-Dark Character Sheet</span>
                    <input type="text" class="section-title-input" value="Wine-Dark Character Sheet">
                    <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                </div>
                <div class="section-actions">
                     <button class="action-btn color-picker-btn" title="Change Color">
                         üé®
                         <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                     </button>
                     <button class="action-btn delete-mode-btn" onclick="toggleGlobalDeleteMode(this)" title="Toggle Delete Mode">üóëÔ∏è</button>
                </div>
            </div>
            <div class="section-content">
                <div class="header-fields-grid">
                    <div> <label for="char-name">Character Name:</label> <input type="text" id="char-name" placeholder="Enter Name"> </div>
                    <div>
                        <label for="char-class-select">Class:</label>
                        <select id="char-class-select" onchange="handleClassChange(this)">
                            <option value="Wretch">Wretch</option>
                            <option value="Serf">Serf</option>
                            <option value="Commoner" selected>Commoner</option>
                            <option value="Gentleman">Gentleman</option>
                            <option value="Noble">Noble</option>
                        </select>
                    </div>
                    <div> <label for="char-profession">Profession:</label> <input type="text" id="char-profession" placeholder="e.g., Shepherd, Merchant"> </div>
                    <div> <label for="char-experience">XP Earned:</label> <input type="number" id="char-experience" value="0" placeholder="100" oninput="updateXpSpent()"> </div>
                    <div> <label for="xp-spent">XP Spent:</label> <input type="number" id="xp-spent" value="0" readonly> </div>
                </div>
                <div id="goal-container">
                    <label for="char-goal">Goal:</label>
                    <input type="text" id="char-goal" placeholder="Enter current goal">
                </div>
            </div>
        </div>

        <div class="styled-section" data-section-id="characteristics" data-deletable="false">
            <div class="section-header">
                <div class="section-title-container">
                    <span class="section-title-text">Characteristics</span>
                    <input type="text" class="section-title-input" value="Characteristics">
                    <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                </div>
                <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                </div>
            </div>
            <div class="section-content">
                 <div class="characteristic-entry"> <label for="str" class="font-bold">STR</label> <input type="number" id="str" value="0" oninput="updatePercentages()"> <input type="text" id="str-percent" value="0%" class="percent-display" readonly> <button class="dice-roller-btn" onclick="rollCharacteristic(this, 'str')">üé≤</button> </div>
                <div class="characteristic-entry"> <label for="dex" class="font-bold">DEX</label> <input type="number" id="dex" value="0" oninput="updatePercentages()"> <input type="text" id="dex-percent" value="0%" class="percent-display" readonly> <button class="dice-roller-btn" onclick="rollCharacteristic(this, 'dex')">üé≤</button> </div>
                <div class="characteristic-entry"> <label for="con" class="font-bold">CON</label> <input type="number" id="con" value="0" oninput="updateHpDisplay(); updatePercentages();"> <input type="text" id="con-percent" value="0%" class="percent-display" readonly> <button class="dice-roller-btn" onclick="rollCharacteristic(this, 'con')">üé≤</button> </div>
                <div id="dynamic-stats-container"></div>
            </div>
        </div>

        <div class="styled-section" data-section-id="combat-details" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Combat Details</span>
                     <input type="text" class="section-title-input" value="Combat Details">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                    <button class="delete-section-btn" onclick="removeFullSection(this)" title="Delete Section">X</button>
                 </div>
            </div>
            <div class="section-content">
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Combat Skills</span> </h4>
                     <div id="combat-skills-display" class="combat-skills-grid">
                         </div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('combat-skills-display', combatStatTemplate)" title="Add Combat Stat">+</button></div>
                 </div>
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Melee Weapons</span></h4>
                     <div class="weapon-header text-xs"> <span></span><span>Weapon</span><span>%</span><span>Damage</span><span>STR</span><span>Notes</span><span></span> </div>
                     <div id="melee-weapons-container">
                         </div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('melee-weapons-container', meleeWeaponTemplate)" title="Add Melee Weapon">+</button></div>
                 </div>
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Ranged Weapons</span></h4>
                     <div class="weapon-header text-xs"> <span></span><span>Weapon</span><span>%</span><span>Damage</span><span>STR</span><span>Notes</span><span></span> </div>
                     <div id="ranged-weapons-container">
                         </div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('ranged-weapons-container', rangedWeaponTemplate)" title="Add Ranged Weapon">+</button></div>
                 </div>
                 <div class="sub-section">
                      <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Hit Locations</span></h4>
                      <div class="section-content hit-location-content p-0">
                          <div class="hit-location" data-loc="head">
                              <label>Head</label>
                              <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input" id="head-ap-current">/<input type="number" value="0" class="hp-ap-input" id="head-ap-max"></div>
                              <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="head" id="head-hp-current">/<span class="hp-max" data-location="head">0</span></div>
                              <input type="text" class="hit-location-item-input" id="head-item" placeholder="Item">
                          </div>
                          <div class="hit-location" data-loc="l-arm">
                              <label>L. Arm</label>
                              <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input" id="l-arm-ap-current">/<input type="number" value="0" class="hp-ap-input" id="l-arm-ap-max"></div>
                              <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="arm" id="l-arm-hp-current">/<span class="hp-max" data-location="arm">0</span></div>
                              <input type="text" class="hit-location-item-input" id="l-arm-item" placeholder="Item">
                          </div>
                          <div class="hit-location" data-loc="chest">
                              <label>Chest</label>
                              <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input" id="chest-ap-current">/<input type="number" value="0" class="hp-ap-input" id="chest-ap-max"></div>
                              <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="chest" id="chest-hp-current">/<span class="hp-max" data-location="chest">0</span></div>
                              <input type="text" class="hit-location-item-input" id="chest-item" placeholder="Item">
                          </div>
                          <div class="hit-location" data-loc="r-arm">
                              <label>R. Arm</label>
                              <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input" id="r-arm-ap-current">/<input type="number" value="0" class="hp-ap-input" id="r-arm-ap-max"></div>
                              <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="arm" id="r-arm-hp-current">/<span class="hp-max" data-location="arm">0</span></div>
                              <input type="text" class="hit-location-item-input" id="r-arm-item" placeholder="Item">
                          </div>
                          <div class="hit-location" data-loc="gut">
                              <label>Gut</label>
                              <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input" id="gut-ap-current">/<input type="number" value="0" class="hp-ap-input" id="gut-ap-max"></div>
                              <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="abdomen" id="gut-hp-current">/<span class="hp-max" data-location="abdomen">0</span></div>
                              <input type="text" class="hit-location-item-input" id="gut-item" placeholder="Item">
                          </div>
                          <div class="hit-location" data-loc="l-leg">
                              <label>L. Leg</label>
                              <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input" id="l-leg-ap-current">/<input type="number" value="0" class="hp-ap-input" id="l-leg-ap-max"></div>
                              <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="leg" id="l-leg-hp-current">/<span class="hp-max" data-location="leg">0</span></div>
                              <input type="text" class="hit-location-item-input" id="l-leg-item" placeholder="Item">
                          </div>
                          <div class="hit-location" data-loc="r-leg">
                              <label>R. Leg</label>
                              <div class="stat-line">AP:<input type="number" value="0" class="hp-ap-input" id="r-leg-ap-current">/<input type="number" value="0" class="hp-ap-input" id="r-leg-ap-max"></div>
                              <div class="stat-line">HP:<input type="number" value="0" class="hp-ap-input hp-current" data-location="leg" id="r-leg-hp-current">/<span class="hp-max" data-location="leg">0</span></div>
                              <input type="text" class="hit-location-item-input" id="r-leg-item" placeholder="Item">
                          </div>
                    </div>
                 </div>
            </div>
        </div>

        <div class="styled-section" data-section-id="skills" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Skills</span>
                     <input type="text" class="section-title-input" value="Skills">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                    <button class="delete-section-btn" onclick="removeFullSection(this)" title="Delete Section">X</button>
                 </div>
             </div>
            <div class="section-content text-sm">
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Core Skills</span></h4>
                     <div id="skills-container">
                          </div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('skills-container', skillTemplate)" title="Add Skill">+</button></div>
                 </div>
                 <div class="sub-section mb-4 border-b pb-4">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Knowledge</span></h4>
                     <div id="knowledge-container">
                          </div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('knowledge-container', knowledgeTemplate)" title="Add Knowledge">+</button></div>
                 </div>
                 <div class="sub-section">
                     <h4 class="font-semibold mb-1 text-sm flex justify-between items-center"> <span>Craft / Art</span></h4>
                     <div id="craft-art-container">
                         </div>
                      <div class="text-center mt-2"><button class="add-entry-footer-btn" onclick="addEntry('craft-art-container', craftArtTemplate)" title="Add Craft/Art">+</button></div>
                 </div>
            </div>
        </div>

        <div class="styled-section" data-section-id="inventory" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Inventory</span>
                     <input type="text" class="section-title-input" value="Inventory">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                    <button class="delete-section-btn" onclick="removeFullSection(this)" title="Delete Section">X</button>
                 </div>
             </div>
            <div class="section-content">
                <div class="sub-section mb-4 border-b pb-4">
                    <h4 class="font-semibold mb-1 text-sm">Backpack (5 slots)</h4>
                    <input type="text" id="backpack-slot-1" placeholder="Slot 1">
                    <input type="text" id="backpack-slot-2" placeholder="Slot 2">
                    <input type="text" id="backpack-slot-3" placeholder="Slot 3">
                    <input type="text" id="backpack-slot-4" placeholder="Slot 4">
                    <input type="text" id="backpack-slot-5" placeholder="Slot 5">
                </div>
                <div class="sub-section mb-4 border-b pb-4">
                    <h4 class="font-semibold mb-1 text-sm">Satchel</h4>
                    <textarea id="satchel-items" placeholder="List satchel items..." class="auto-expand"></textarea>
                    <label for="coin" class="mt-2">Coin:</label>
                    <input type="number" id="coin" value="10">
                     <div class="text-center mt-4">
                         <button onclick="addInventorySection()" class="add-entry-footer-btn" title="Add Inventory Container">+</button>
                     </div>
                 </div>
                 <div id="dynamic-inventory-container" class="grid grid-cols-1 gap-4">
                     </div>
             </div>
        </div>

        <div class="styled-section" data-section-id="description" data-deletable="true">
            <div class="section-header">
                <div class="section-title-container">
                    <span class="section-title-text">Description & Flaws</span>
                    <input type="text" class="section-title-input" value="Description & Flaws">
                    <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                </div>
                <div class="section-actions">
                     <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                    <button class="delete-section-btn" onclick="removeFullSection(this)" title="Delete Section">X</button>
                </div>
            </div>
            <div class="section-content description-fields-grid">
                 <div>
                     <textarea id="char-desc" placeholder="Enter character description, goals..." class="h-full auto-expand"></textarea>
                 </div>
                 <div>
                     <textarea id="char-flaws" placeholder="Enter descriptions of your character's vices, fears, and misfortunes. Describe how they affect your character." class="h-full auto-expand"></textarea>
                 </div>
            </div>
        </div>

        <div class="styled-section" data-section-id="powers" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Powers</span>
                     <input type="text" class="section-title-input" value="Powers">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                    <button class="delete-section-btn" onclick="removeFullSection(this)" title="Delete Section">X</button>
                 </div>
            </div>
             <div id="powers-container" class="section-content">
                 </div>
             <div class="section-footer"><button class="add-entry-footer-btn" onclick="addEntry('powers-container', powerTemplate)" title="Add Power/Note">+</button></div>
         </div>

         <div class="styled-section" data-section-id="notes" data-deletable="true">
             <div class="section-header">
                 <div class="section-title-container">
                     <span class="section-title-text">Notes</span>
                     <input type="text" class="section-title-input" value="Notes">
                     <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                 </div>
                 <div class="section-actions">
                    <button class="action-btn color-picker-btn" title="Change Color">
                        üé®
                        <input type="color" class="color-picker-input" onchange="changeSectionColor(this)">
                    </button>
                    <button class="delete-section-btn" onclick="removeFullSection(this)" title="Delete Section">X</button>
                 </div>
            </div>
             <div id="notes-container" class="section-content">
                 <textarea id="notes-text" placeholder="General notes..." class="h-full auto-expand"></textarea>
             </div>
         </div>

    </div> <div id="dice-result-popup" onclick="this.style.display='none'"></div>


    <script>
        // --- Constants ---
        const LOCAL_STORAGE_KEY = 'wineDarkSheetData_v3'; // Use a versioned key

        // --- Template Strings for Dynamic Entries ---
        // Use span for predefined skill names, input for user-added ones
        const skillTemplate = `<div class="dynamic-entry skill-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Skill">-</button><span class="skill-name-display" data-base-skill="" data-base-percent="0">Skill Name</span><input type="text" placeholder="Skill Name" class="skill-name-input flex-grow" style="display:none;" oninput="updateDynamicSkillLabel(this)"><input type="number" value="0" class="skill-rank-input" oninput="updateSkillPercentage(this)"><input type="number" value="0" class="skill-percent-display percent-display" readonly><button class="dice-roller-btn" onclick="rollPercentile(this)">üé≤</button></div>`;
        const knowledgeTemplate = `<div class="dynamic-entry skill-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Knowledge">-</button><span class="skill-name-display" data-base-skill="" data-base-percent="0">Knowledge Area</span><input type="text" placeholder="Knowledge Area" class="skill-name-input flex-grow" style="display:none;" oninput="updateDynamicSkillLabel(this)"><input type="number" value="0" class="skill-rank-input" oninput="updateSkillPercentage(this)"><input type="number" value="0" class="skill-percent-display percent-display" readonly><button class="dice-roller-btn" onclick="rollPercentile(this)">üé≤</button></div>`;
        // --- UPDATED: Craft/Art template now matches Knowledge template ---
        const craftArtTemplate = `<div class="dynamic-entry skill-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Craft/Art">-</button><span class="skill-name-display" data-base-skill="" data-base-percent="0">Craft/Art Name</span><input type="text" placeholder="Craft/Art Name" class="skill-name-input flex-grow" style="display:none;" oninput="updateDynamicSkillLabel(this)"><input type="number" value="0" class="skill-rank-input" oninput="updateSkillPercentage(this)"><input type="number" value="0" class="skill-percent-display percent-display" readonly><button class="dice-roller-btn" onclick="rollPercentile(this)">üé≤</button></div>`;
        const combatStatTemplate = `<div class="dynamic-entry skill-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Stat">-</button><span class="skill-name-display" data-base-skill="" data-base-percent="0">Combat Stat</span><input type="text" placeholder="Combat Stat Name" class="skill-name-input flex-grow" style="display:none;" oninput="updateDynamicSkillLabel(this)"><input type="number" value="0" class="skill-rank-input" oninput="updateSkillPercentage(this)"><input type="number" value="0" class="skill-percent-display percent-display" readonly><button class="dice-roller-btn" onclick="rollPercentile(this)">üé≤</button></div>`;
        const meleeWeaponTemplate = `<div class="dynamic-entry weapon-entry" data-weapon-type="melee"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Weapon">-</button><textarea placeholder="Weapon Name" class="auto-expand" rows="1" oninput="autoExpandTextarea(this)"></textarea><input type="number" value="0" class="text-center skill-percent-input" oninput="updateXpSpent()"><input type="text" placeholder="e.g. 1d4" class="dmg-input"><span class="str-dmg-mod">(+0)</span><textarea placeholder="Notes" class="auto-expand" rows="1" oninput="autoExpandTextarea(this)"></textarea><button class="dice-roller-btn" onclick="rollWeaponAttack(this)">üé≤</button></div>`;
        const rangedWeaponTemplate = `<div class="dynamic-entry weapon-entry" data-weapon-type="ranged"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Weapon">-</button><textarea placeholder="Weapon Name" class="auto-expand" rows="1" oninput="autoExpandTextarea(this)"></textarea><input type="number" value="0" class="text-center skill-percent-input" oninput="updateXpSpent()"><input type="text" placeholder="e.g. 1d6" class="dmg-input"><span class="str-dmg-mod">(+0)</span><textarea placeholder="Notes" class="auto-expand" rows="1" oninput="autoExpandTextarea(this)"></textarea><button class="dice-roller-btn" onclick="rollWeaponAttack(this)">üé≤</button></div>`;
        const powerTemplate = `<div class="dynamic-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Power/Note">-</button><input type="text" placeholder="Power or Note" class="flex-grow"></div>`;
        const inventorySlotTemplate = `<div class="dynamic-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Slot">-</button><input type="text" placeholder="Item Slot" class="flex-grow"></div>`;

        // --- Default Sheet Structure (for Reset) ---
        const defaultSheetStructure = {
            skills: {
                core: [
                    { baseSkill: "Climb", basePercent: 0, attribute: "STR", multiplier: 2 },
                    { baseSkill: "Disguise", basePercent: 1 },
                    { baseSkill: "First Aid", basePercent: 30 },
                    { baseSkill: "Herbalism", basePercent: 5 },
                    { baseSkill: "Hide", basePercent: 10 },
                    { baseSkill: "Knots", basePercent: 10 },
                    { baseSkill: "Listen", basePercent: 25 },
                    { baseSkill: "Research", basePercent: 25 },
                    { baseSkill: "Spot", basePercent: 25 },
                    { baseSkill: "Teach", basePercent: 10 },
                    { baseSkill: "Track", basePercent: 10 }
                ],
                knowledge: [
                    { baseSkill: "Church", basePercent: 0 },
                    { baseSkill: "Law", basePercent: 0 },
                    { baseSkill: "Literacy", basePercent: 0 },
                    { baseSkill: "Sport", basePercent: 0 }
                ],
                craftArt: [
                    // --- UPDATED: Default Smith skill uses baseSkill now ---
                    { baseSkill: "Smith", basePercent: 1, rank: "0" }
                ]
            },
            combat: {
                skills: [
                    { baseSkill: "Melee", basePercent: 25 },
                    { baseSkill: "Range", basePercent: 25 },
                    { baseSkill: "Dodge", basePercent: 0, attribute: "DEX", multiplier: 2 }
                ],
                meleeWeapons: [],
                rangedWeapons: []
                // Default Hit Locations are handled in HTML and reset function
            }
        };

        // --- Debounce Utility ---
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        // --- Local Storage Functions ---
        function saveSheetToLocalStorage() {
            try {
                const sheetData = gatherSheetData();
                const jsonData = JSON.stringify(sheetData);
                localStorage.setItem(LOCAL_STORAGE_KEY, jsonData);
                 // console.log("Sheet data saved to local storage."); // DEBUGGING
            } catch (error) {
                console.error("Error saving sheet data to local storage:", error);
                showDicePopup("Error saving sheet data. See console.");
            }
        }

        // Create a debounced version of the save function
        const debouncedSave = debounce(saveSheetToLocalStorage, 500); // Save 500ms after last change

        function loadSheetFromLocalStorage() {
            // console.log("Attempting to load sheet from local storage..."); // DEBUGGING
            try {
                const jsonData = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (jsonData) {
                    // console.log("Found saved data:", jsonData.substring(0, 200) + "..."); // DEBUGGING - Log start of data
                    const data = JSON.parse(jsonData);
                    // Basic validation - check if it looks like our data
                    if (typeof data === 'object' && data !== null && data.version && data.version >= 3) { // Updated version check if needed
                        // console.log("Parsed data version:", data.version); // DEBUGGING
                        // --- IMPORTANT: Reset sheet state *before* populating ---
                        setDefaultSheetState(false); // Reset sheet without recalculating yet
                        populateSheetData(data); // Populate the DOM from saved data
                        // console.log("Sheet data loaded successfully from local storage. Recalculating..."); // DEBUGGING
                        // Recalculate everything *after* populating
                        updateHpDisplay();
                        updatePercentages(); // This includes skills and STR mod
                        updateXpSpent();
                        // console.log("Recalculations complete after load."); // DEBUGGING
                        return true; // Indicate successful load
                    } else {
                        console.warn("Invalid or outdated data found in local storage. Version:", data?.version); // DEBUGGING
                        localStorage.removeItem(LOCAL_STORAGE_KEY); // Remove invalid data
                    }
                } else {
                    // console.log("No data found in local storage for key:", LOCAL_STORAGE_KEY); // DEBUGGING
                }
            } catch (error) {
                console.error("Error loading or parsing sheet data from local storage:", error); // DEBUGGING
                showDicePopup("Error loading saved data. Resetting. See console.");
                localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear potentially corrupted data
            }

            // If function hasn't returned true, it means loading failed or no data found
            // console.log("Loading failed or no data found. Setting default state."); // DEBUGGING
            setDefaultSheetState(true); // Set default state and calculate
            return false; // Indicate load failed or no data
        }


        // --- Auto-expand Textarea ---
        function autoExpandTextarea(textarea) {
            if (textarea) {
                textarea.style.height = 'auto'; // Temporarily shrink to base height
                textarea.style.height = textarea.scrollHeight + 'px'; // Set to scroll height
            }
        }

        // --- Core Add/Remove Functions ---
        function addEntry(containerId, template, data = null) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error("Container not found:", containerId);
                return null; // Return null if container not found
            }

            container.insertAdjacentHTML('beforeend', template);
            const newEntry = container.lastElementChild;
            if (!newEntry) {
                console.error("Failed to add new entry to container:", containerId);
                return null; // Return null if entry creation failed
            }

            // Initialize auto-expand for textareas within the new entry
            newEntry.querySelectorAll('textarea.auto-expand').forEach(ta => {
                ta.addEventListener('input', () => autoExpandTextarea(ta));
                autoExpandTextarea(ta); // Initial call
            });

            // Populate data if provided (for import or load)
            if (data) {
                try { // Wrap population in try-catch for better error isolation
                    if (newEntry.classList.contains('skill-entry')) {
                        const nameSpan = newEntry.querySelector('.skill-name-display');
                        const nameInput = newEntry.querySelector('.skill-name-input');
                        const rankInput = newEntry.querySelector('.skill-rank-input');

                        // Determine if it's a predefined skill (has baseSkill) or custom (has name)
                        const isPredefined = !!data.baseSkill; // Skill defined in defaultSheetStructure
                        const isCustom = !!data.name && !isPredefined; // Custom skill loaded from save data

                        // --- UPDATED: Consistent handling for all skill types (Core, Knowledge, Craft/Art, Combat) ---
                        if (isPredefined && nameSpan && nameInput) {
                            // Populate predefined skill (using span, hide input)
                            nameSpan.textContent = data.baseSkill; // Set initial text
                            nameSpan.dataset.baseSkill = data.baseSkill;
                            if (data.basePercent !== undefined) nameSpan.dataset.basePercent = data.basePercent;
                            if (data.attribute) nameSpan.dataset.attribute = data.attribute;
                            if (data.multiplier) nameSpan.dataset.multiplier = data.multiplier;
                            nameSpan.style.display = ''; // Show span
                            nameInput.style.display = 'none'; // Hide input
                        } else if (isCustom && nameSpan && nameInput) {
                            // Populate custom skill (using input, hide span)
                            nameInput.value = data.name;
                            nameInput.dataset.baseSkill = data.name; // Store name as baseSkill identifier
                            if (data.basePercent !== undefined) nameInput.dataset.basePercent = data.basePercent;
                            nameInput.style.display = ''; // Show input
                            nameSpan.style.display = 'none'; // Hide span
                        } else {
                            console.warn("Could not determine skill type or find elements for skill entry:", data, "in container:", containerId);
                        }

                        if (rankInput) {
                             if (data.rank !== undefined) rankInput.value = data.rank;
                             // Call updateSkillPercentage AFTER potentially setting name/baseSkill
                             updateSkillPercentage(rankInput);
                        } else {
                            console.warn("Could not find rankInput for skill entry:", data);
                        }

                    } else if (newEntry.classList.contains('weapon-entry')) {
                        const nameTextarea = newEntry.querySelector('textarea[placeholder="Weapon Name"]');
                        const percentInput = newEntry.querySelector('.skill-percent-input');
                        const dmgInput = newEntry.querySelector('.dmg-input');
                        const notesTextarea = newEntry.querySelector('textarea[placeholder="Notes"]');

                        if (nameTextarea && data.name !== undefined) nameTextarea.value = data.name;
                        if (percentInput && data.percent !== undefined) percentInput.value = data.percent;
                        if (dmgInput && data.damage !== undefined) dmgInput.value = data.damage;
                        if (notesTextarea && data.notes !== undefined) notesTextarea.value = data.notes;

                        // Ensure auto-expand after setting value
                        if (nameTextarea) autoExpandTextarea(nameTextarea);
                        if (notesTextarea) autoExpandTextarea(notesTextarea);
                        updateStrDamageModifiers(); // Update STR mod display

                    } else if (newEntry.querySelector('input[placeholder="Item Slot"]')) { // Inventory Slot
                        const itemInput = newEntry.querySelector('input[placeholder="Item Slot"]');
                        if(itemInput && data.item !== undefined) itemInput.value = data.item;
                    } else if (newEntry.querySelector('input[placeholder="Power or Note"]')) { // Power/Note
                        const powerInput = newEntry.querySelector('input[placeholder="Power or Note"]');
                        if(powerInput && data.text !== undefined) powerInput.value = data.text;
                    }
                } catch (error) {
                    console.error("Error populating entry:", error, "Data:", data, "Entry:", newEntry);
                }
            } else {
                 // Handle adding a *new* blank skill entry (user clicked '+')
                 if (newEntry.classList.contains('skill-entry')) {
                     const nameSpan = newEntry.querySelector('.skill-name-display');
                     const nameInput = newEntry.querySelector('.skill-name-input');
                     // --- UPDATED: Show input immediately for *any* new skill entry ---
                     if (nameSpan && nameInput) {
                         nameSpan.style.display = 'none'; // Hide span
                         nameInput.style.display = ''; // Show input
                         nameInput.focus(); // Focus the input for easy typing
                     }
                     // Ensure XP updates when adding a blank skill
                     updateXpSpent();
                 }
                 // Ensure XP updates when adding a blank weapon
                 if (newEntry.classList.contains('weapon-entry')) {
                     updateXpSpent();
                 }
            }

            return newEntry; // Return the newly created entry element
        }


        function removeEntry(buttonElement) {
            const entry = buttonElement.closest('.dynamic-entry');
            if (entry) {
                const isSkill = entry.classList.contains('skill-entry');
                const isWeapon = entry.classList.contains('weapon-entry');
                entry.remove();
                // Update XP Spent if a skill or weapon was removed
                if (isSkill || isWeapon) {
                    updateXpSpent();
                }
                 // Save after removing an entry
                 debouncedSave();
            }
        }

        // --- Inventory Section Functions ---
        let sectionCounter = 0;
        function addInventorySection(data = null) {
            sectionCounter++;
            const slotsContainerId = `dynamic-inventory-slots-${sectionCounter}`;
            const sectionId = `dynamic-inventory-section-${sectionCounter}`;
            const title = data?.title || `New Inventory ${sectionCounter}`;
            const color = data?.color || getRandomColor(); // Use imported color or random

            const inventorySectionTemplate = `
                <div id="${sectionId}" class="styled-section dynamic-inventory-section" data-section-id="${sectionId}" data-deletable="true">
                     <div class="section-header" style="background-color: ${color};">
                         <div class="section-title-container">
                             <span class="section-title-text">${title}</span>
                             <input type="text" class="section-title-input" value="${title}">
                             <button class="action-btn edit-title-btn" onclick="toggleTitleEdit(this)">‚úèÔ∏è</button>
                         </div>
                         <div class="section-actions">
                              <button class="action-btn color-picker-btn" title="Change Color">
                                  üé®
                                  <input type="color" class="color-picker-input" value="${color}" onchange="changeSectionColor(this)">
                              </button>
                              <button class="delete-section-btn" onclick="removeFullSection(this)" title="Delete Section">X</button>
                         </div>
                     </div>
                     <div id="${slotsContainerId}" class="section-content">
                         ${!data ? `<div class="dynamic-entry"><button class="remove-btn" onclick="removeEntry(this)" title="Remove Slot">-</button> <input type="text" placeholder="Item Slot" class="flex-grow"> </div>` : ''}
                     </div>
                      <div class="section-footer"><button class="add-entry-footer-btn" onclick="addEntry('${slotsContainerId}', inventorySlotTemplate)" title="Add Slot">+</button></div>
                 </div>`;
            document.getElementById('dynamic-inventory-container')?.insertAdjacentHTML('beforeend', inventorySectionTemplate);

            // Populate slots if data is provided
            if (data && data.items) {
                const slotsContainer = document.getElementById(slotsContainerId);
                if (slotsContainer) {
                    // Clear any default slot added by the template if loading data
                    if (slotsContainer.querySelector('.dynamic-entry')) {
                        slotsContainer.innerHTML = '';
                    }
                    data.items.forEach(itemData => addEntry(slotsContainerId, inventorySlotTemplate, itemData));
                }
            }
            // Save after adding section (if not part of initial load/import)
            if (!data) { // Only save if it's a user action, not during load
                 debouncedSave();
            }
        }


        // --- Generic Section Management ---
        function removeFullSection(buttonElement) {
             const section = buttonElement.closest('.styled-section');
             if (section && section.dataset.deletable === 'true') {
                 if (confirm('Are you sure you want to delete this entire section?')) {
                     section.remove();
                     debouncedSave(); // Save after removing section
                 }
             }
        }

        function toggleTitleEdit(buttonElement) {
            const titleContainer = buttonElement.closest('.section-title-container');
            const titleText = titleContainer.querySelector('.section-title-text');
            const titleInput = titleContainer.querySelector('.section-title-input');
            if (!titleContainer || !titleText || !titleInput) return;

            const saveEdit = () => {
                if (titleInput && titleText) { // Ensure elements exist
                    titleText.textContent = titleInput.value;
                    titleContainer.classList.remove('editing');
                    titleInput.onblur = null;
                    titleInput.onkeydown = null;
                    debouncedSave(); // Save after editing title
                }
            };

            const cancelEdit = () => {
                 if (titleInput && titleText) { // Ensure elements exist
                    titleInput.value = titleText.textContent; // Revert input value
                    titleContainer.classList.remove('editing');
                    titleInput.onblur = null;
                    titleInput.onkeydown = null;
                    // No save needed on cancel
                 }
            }

            if (titleContainer.classList.contains('editing')) {
                saveEdit();
            } else {
                titleInput.value = titleText.textContent;
                titleContainer.classList.add('editing');
                titleInput.focus();
                titleInput.select();
                // Save on blur (when focus is lost)
                titleInput.onblur = saveEdit;
                // Handle Enter/Escape keys
                titleInput.onkeydown = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault(); // Prevent form submission if any
                        titleInput.blur(); // Trigger saveEdit via blur
                    } else if (event.key === 'Escape') {
                        cancelEdit();
                    }
                };
            }
        }
        function changeSectionColor(colorInputElement) {
             colorInputElement.closest('.section-header')?.style.setProperty('background-color', colorInputElement.value);
             // Save is triggered by the main event listener
         }
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                // Generate slightly darker/less saturated colors
                color += letters[Math.floor(Math.random() * 12)]; // Use 0-B instead of 0-F
            }
            return color;
        }

        // --- Delete Mode ---
        function toggleGlobalDeleteMode(buttonElement) {
            const container = document.getElementById('character-sheet-container');
            if (container) {
                container.classList.toggle('delete-mode-active');
                buttonElement.classList.toggle('active');
                // No save needed for toggling delete mode itself
            }
        }

        // --- Dice Rolling Helper ---
        function rollSingleDie(sides) {
            sides = Math.max(1, sides);
            return Math.floor(Math.random() * sides) + 1;
        }

        // --- Dice Parsing and Calculation Helpers ---
        function parseDiceString(diceString) {
            diceString = String(diceString || '0').toLowerCase().replace(/\s+/g, '');
            let numDice = 0, numSides = 0, flatModifier = 0, sign = '+';

            // Extract sign if present at the beginning
            if (diceString.startsWith('+') || diceString.startsWith('-')) {
                sign = diceString[0];
                diceString = diceString.substring(1);
            }

            // Match dice notation (e.g., "2d6", "d10")
            const diceRegex = /(\d+)?d(\d+)/;
            const diceMatch = diceString.match(diceRegex);

            if (diceMatch) {
                numDice = diceMatch[1] ? parseInt(diceMatch[1]) : 1;
                numSides = parseInt(diceMatch[2]);
                // Remove the dice part from the string to find the modifier
                diceString = diceString.replace(diceRegex, '').trim();
            }

            // Check for remaining part as flat modifier
            if (diceString) {
                 // Handle modifier signs explicitly
                 if (diceString.startsWith('+')) {
                     flatModifier = parseInt(diceString.substring(1)) || 0;
                 } else if (diceString.startsWith('-')) {
                     flatModifier = -(parseInt(diceString.substring(1)) || 0);
                 } else if (!isNaN(parseInt(diceString))) {
                     // If no sign, assume positive modifier *if* dice were present,
                     // otherwise it's just a flat number
                     if (diceMatch) {
                         flatModifier = parseInt(diceString);
                     } else {
                         // If no 'd' was found, the whole initial string (after sign removal) is the flat modifier
                         flatModifier = parseInt(diceString);
                         // If the original string was just a sign, modifier is 0
                         if (isNaN(flatModifier)) flatModifier = 0;
                     }
                 }
            }

             // If no dice and no modifier found, but the original string was just a number
             if (numDice === 0 && flatModifier === 0 && !isNaN(parseInt(diceString))) {
                 flatModifier = parseInt(diceString);
             }

             // If the original string was just a sign (e.g., "+"), treat as 0
             if (numDice === 0 && flatModifier === 0 && (diceString === '+' || diceString === '-')) {
                 flatModifier = 0;
             }


            return { numDice, numSides, flatModifier, sign };
        }


        function rollParsedDice(parsedResult) {
            let diceTotal = 0;
            let rolls = [];
            for (let i = 0; i < parsedResult.numDice; i++) {
                const roll = rollSingleDie(parsedResult.numSides);
                rolls.push(roll);
                diceTotal += roll;
            }
            let totalValue = diceTotal + parsedResult.flatModifier;
            let rollsString = "";

            if (parsedResult.numDice > 0) {
                rollsString = `${parsedResult.numDice}d${parsedResult.numSides} (${rolls.join(', ')})`;
                if (parsedResult.flatModifier !== 0) {
                     rollsString += (parsedResult.flatModifier > 0 ? ` + ${parsedResult.flatModifier}` : ` - ${Math.abs(parsedResult.flatModifier)}`);
                }
            } else if (parsedResult.flatModifier !== 0) {
                rollsString = `${parsedResult.flatModifier}`;
            } else {
                rollsString = "0"; // Explicitly show 0 if no dice and no modifier
            }

            // Apply the overall sign if needed (only affects the final value)
            if (parsedResult.sign === '-') {
                totalValue = -totalValue;
                // Add sign to the string representation unless it's just "0"
                if (rollsString !== "0") {
                     rollsString = parsedResult.sign + rollsString;
                }
            }

            return { totalValue, rollsString };
        }


        function getMaxParsedDice(parsedResult) {
             let maxDiceValue = parsedResult.numDice * parsedResult.numSides;
             let maxValue = maxDiceValue + parsedResult.flatModifier;
             if (parsedResult.sign === '-') maxValue = -maxValue;
             return maxValue;
        }


        // --- Dice Roller & Related Functions ---
        const dicePopup = document.getElementById('dice-result-popup');
        let currentRoller = null; // Track which button opened the popup

        function showDicePopup(content) {
            if(dicePopup) {
                dicePopup.innerHTML = content;
                dicePopup.style.display = 'block';
            } else {
                console.error("Dice popup element not found!");
            }
        }

        // Generic function to close the dice popup
        function closeDicePopup() {
             if (dicePopup) {
                 dicePopup.style.display = 'none';
             }
             currentRoller = null;
        }

        function rollPercentile(buttonElement) {
            if (!dicePopup) return; // Prevent errors if popup missing
            // If the same button is clicked again while popup is open, close it
            if (currentRoller === buttonElement && dicePopup.style.display === 'block') {
                closeDicePopup();
                return;
            }

            const entry = buttonElement.closest('.dynamic-entry');
            const skillPercentDisplay = entry?.querySelector('.skill-percent-display');
            // Read the *current* value, considering modifiers
            const skillValue = skillPercentDisplay ? parseInt(skillPercentDisplay.value) || 0 : 0;
            const skillNameElement = entry?.querySelector('.skill-name-display') || entry?.querySelector('.skill-name-input');
            let skillName = "Skill";
            if (skillNameElement) {
                // Prioritize baseSkill for predefined, then input value for custom
                skillName = skillNameElement.dataset.baseSkill || (skillNameElement.tagName === 'INPUT' ? skillNameElement.value : skillNameElement.textContent.split(' (')[0]) || "Skill";
            }

            const roll = rollSingleDie(100);
            const success = roll <= skillValue && roll < 100; // 100 is always fumble
            const resultColor = success ? '#4ade80' : '#f87171'; // Green for success, Red for fail/fumble

            let popupContent = `<span style="color:${resultColor}; font-weight: bold;">${roll}</span> <span class="text-xs ml-2">vs ${skillValue}% (${skillName})</span>`;

            if (roll === 100) {
                popupContent += `<span class="fumble-roll-text">Fumble!</span>`;
            } else if (roll <= 5 && success) { // Check for critical success (example: roll <= 5)
                 popupContent += `<span class="critical-roll-text">Critical!</span>`;
            } else if (!success) {
                // Optional: Add specific text for failure?
                // popupContent += ` (Fail)`;
            }


            showDicePopup(popupContent);
            currentRoller = buttonElement; // Set the current roller
        }

        function rollCharacteristic(buttonElement, charName) {
             if (!dicePopup) return;
             // If the same button is clicked again while popup is open, close it
             if (currentRoller === buttonElement && dicePopup.style.display === 'block') {
                 closeDicePopup();
                 return;
             }

            const percentDisplay = document.getElementById(`${charName}-percent`);
            // Read the *current* value from the display, considering modifiers
            let charValue = percentDisplay ? parseInt(percentDisplay.value.replace('%','')) || 0 : 0;
            const charLabel = charName.toUpperCase();

            const roll = rollSingleDie(100);
            const success = roll <= charValue && roll < 100; // 100 is always fumble
            const resultColor = success ? '#4ade80' : '#f87171'; // Green for success, Red for fail/fumble

            let popupContent = `<span style="color:${resultColor}; font-weight: bold;">${roll}</span> <span class="text-xs ml-2">vs ${charValue}% (${charLabel})</span>`;

             if (roll === 100) {
                 popupContent += `<span class="fumble-roll-text">Fumble!</span>`;
             } else if (roll <= 5 && success) { // Check for critical success (example: roll <= 5)
                 popupContent += `<span class="critical-roll-text">Critical!</span>`;
             }

             showDicePopup(popupContent);
             currentRoller = buttonElement; // Set the current roller
        }


        function rollWeaponAttack(buttonElement) {
             if (!dicePopup) return;
             // If the same button is clicked again while popup is open, close it
             if (currentRoller === buttonElement && dicePopup.style.display === 'block') {
                 closeDicePopup();
                 return;
             }

             const entry = buttonElement.closest('.dynamic-entry');
             const weaponNameInput = entry?.querySelector('textarea[placeholder="Weapon Name"]');
             const weaponName = weaponNameInput?.value || 'Weapon';
             const dmgInput = entry?.querySelector('.dmg-input');
             const baseDmgString = dmgInput?.value || '0';
             const strModElement = entry?.querySelector('.str-dmg-mod');
             const strModString = strModElement ? strModElement.textContent : '(+0)'; // e.g., "(+1d4)" or "(-1d6)"

             const weaponType = entry?.dataset.weaponType; // 'melee' or 'ranged'
             const weaponSkillInput = entry?.querySelector('.skill-percent-input');
             const weaponSkillValue = weaponSkillInput ? parseInt(weaponSkillInput.value) || 0 : 0;

             // Find the corresponding base combat skill (Melee or Range)
             const baseCombatSkillSelector = weaponType === 'melee'
                 ? '#combat-skills-display .skill-entry [data-base-skill="Melee"]' // Target the span/input with the data attribute
                 : '#combat-skills-display .skill-entry [data-base-skill="Range"]';
             const baseCombatSkillElement = document.querySelector(baseCombatSkillSelector);
             const baseSkillPercentDisplay = baseCombatSkillElement?.closest('.skill-entry')?.querySelector('.skill-percent-display');
             // Read the *current* value of the base skill, considering modifiers
             const baseSkillValue = baseSkillPercentDisplay ? parseInt(baseSkillPercentDisplay.value) || 0 : 0;

             // --- UPDATED: Calculate total attack skill ---
             // Base skill contribution is capped at 75% (unless naturally higher, though unlikely with current rules)
             const effectiveBase = Math.min(baseSkillValue, 75);
             // Add the weapon's specific percentage bonus on top
             const totalSkillValue = effectiveBase + weaponSkillValue;
             // Note: The final totalSkillValue can exceed 75% due to the weapon bonus.

             // --- Roll the Attack ---
             const roll = rollSingleDie(100);
             let specialResultText = "";
             let isCrit = roll <= 2; // Critical on 1 or 2
             let isSpecial = roll >= 3 && roll <= 15; // Special effect on 3-15
             let isFumble = roll >= 96; // Fumble on 96-100
             // Determine success: hit if roll <= totalSkillValue AND not a fumble, OR if it's a crit (crit always hits if skill > 0)
             let success = (roll <= totalSkillValue && !isFumble) || (isCrit && totalSkillValue > 0);

             const resultColor = success ? '#4ade80' : '#f87171'; // Green for success, Red for fail/fumble
             let popupContent = `<span style="font-weight: bold;">${weaponName}: </span>`;
             popupContent += `<span style="color:${resultColor}; font-weight: bold;">${roll}</span> <span class="text-xs ml-1">vs ${totalSkillValue}%</span>`;

             // --- Determine Outcome and Damage ---
             if (isFumble) {
                 specialResultText = `<span class="fumble-roll-text">Fumble!</span>`;
                 success = false; // Ensure fumble overrides success
                 popupContent += specialResultText;
                 popupContent += `\n<span style="font-size: 0.9em;">Attack fails!</span>`;
             } else if (success) {
                 const hitLocation = getHitLocation(); // Determine hit location
                 let totalFinalDamage = 0;
                 let damageResultString = "";

                 // Parse base damage and STR modifier strings
                 const parsedBaseDmg = parseDiceString(baseDmgString);
                 const parsedStrMod = parseDiceString(strModString.replace(/[()]/g, '')); // Remove parentheses before parsing

                 if (isCrit) {
                     specialResultText = `<span class="critical-roll-text">Critical! Bypass Armor!</span>`;
                     // Calculate max possible damage (max dice roll + modifier)
                     const maxBase = getMaxParsedDice(parsedBaseDmg);
                     const maxMod = getMaxParsedDice(parsedStrMod);
                     totalFinalDamage = Math.max(0, maxBase + maxMod); // Ensure damage isn't negative
                     damageResultString = `Max ${baseDmgString}${strModString} = <span style="font-weight:bold;">${totalFinalDamage}</span> Damage`;
                 } else if (isSpecial) {
                     specialResultText = `<span class="special-roll-text">Special! Max Damage!</span>`;
                     // Calculate max possible damage
                     const maxBase = getMaxParsedDice(parsedBaseDmg);
                     const maxMod = getMaxParsedDice(parsedStrMod);
                     totalFinalDamage = Math.max(0, maxBase + maxMod);
                     damageResultString = `Max ${baseDmgString}${strModString} = <span style="font-weight:bold;">${totalFinalDamage}</span> Damage`;
                 } else {
                     // Normal Hit: Roll base damage and add modifier
                     const { totalValue: rolledBase, rollsString: baseRolls } = rollParsedDice(parsedBaseDmg);
                     const { totalValue: rolledMod, rollsString: modRolls } = rollParsedDice(parsedStrMod);
                     totalFinalDamage = Math.max(0, rolledBase + rolledMod); // Ensure damage isn't negative

                     // Construct the damage string
                     damageResultString = baseRolls;
                     // Append modifier string if it exists and isn't "0"
                     if (modRolls && modRolls !== "0") {
                         // Add appropriate sign/spacing
                         if (!modRolls.startsWith('+') && !modRolls.startsWith('-')) {
                             damageResultString += " + ";
                         } else {
                             damageResultString += " "; // Add space if sign is present
                         }
                         damageResultString += modRolls;
                     }
                     damageResultString += ` = <span style="font-weight:bold;">${totalFinalDamage}</span> Damage`;
                 }
                 popupContent += specialResultText;
                 popupContent += `\n<span style="font-size: 0.9em;">${damageResultString} to <span style="font-weight:bold;">${hitLocation}</span></span>`;
             } else { // Failed roll (not a fumble)
                 popupContent += `\n<span style="font-size: 0.9em;">Miss!</span>`;
             }

             showDicePopup(popupContent);
             currentRoller = buttonElement; // Set the current roller
        }


        function getHitLocation() {
            const roll = rollSingleDie(100);
            if (roll < 10) return "Head";      // 01-09
            if (roll < 25) return "R. Arm";    // 10-24
            if (roll < 40) return "L. Arm";    // 25-39
            if (roll < 55) return "Chest";     // 40-54
            if (roll < 70) return "Gut";       // 55-69
            if (roll < 85) return "R. Leg";    // 70-84
            return "L. Leg";                    // 85-00
        }

        // --- HP and Percentage Calculation ---
        const conInput = document.getElementById('con');
        const strInput = document.getElementById('str');
        const dexInput = document.getElementById('dex');
        const strPercent = document.getElementById('str-percent');
        const dexPercent = document.getElementById('dex-percent');
        const conPercent = document.getElementById('con-percent');
        const hpMaxElements = document.querySelectorAll('.hp-max');
        const hpCurrentInputs = document.querySelectorAll('.hp-current');

        const hpTable = { // CON score 1-21+
            head:    [0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7], // Index 0 is unused (CON 0)
            arm:     [0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6],
            chest:   [0,1,2,2,2,3,3,4,4,4,5,5,5,6,6,6,7,7,8,8,8,9],
            abdomen: [0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7],
            leg:     [0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]
        };

        function calculateHp(conScore) {
            // Clamp CON score between 1 and 21 for table lookup
            const score = Math.max(1, Math.min(21, parseInt(conScore) || 0));
            return {
                head: hpTable.head[score], arm: hpTable.arm[score], chest: hpTable.chest[score],
                abdomen: hpTable.abdomen[score], leg: hpTable.leg[score]
            };
        }

        function updateHpDisplay() {
            const conScore = conInput ? conInput.value : '0'; // Add null check
            const hpValues = calculateHp(conScore);
            hpMaxElements.forEach(span => {
                if (span) { // Add null check
                    const location = span.dataset.location;
                    if (hpValues[location] !== undefined) span.textContent = hpValues[location];
                }
            });
            hpCurrentInputs.forEach(input => {
                 if (input) { // Add null check
                    const location = input.dataset.location;
                    if (hpValues[location] !== undefined) {
                        const currentVal = parseInt(input.value);
                        const maxVal = hpValues[location];
                        // Reset to max only if current value is invalid or higher than new max
                        // OR if the input is currently empty (e.g., after reset)
                        // *** Use the input's ID to check if it has been loaded/set ***
                        const isLoaded = document.getElementById(input.id)?.dataset.loaded === 'true';
                        if (!isLoaded && (isNaN(currentVal) || currentVal > maxVal || input.value === '')) {
                            input.value = maxVal;
                        }
                        input.max = maxVal; // Update max attribute for potential browser validation
                    }
                 }
            });
             // Save is triggered by the input event listener on the CON input
        }

        function getStrDamageModifier(strScore) {
            const score = parseInt(strScore) || 0;
            if (score <= 2) return "(-?)";    // Very weak
            if (score <= 6) return "(-1d6)";  // Weak
            if (score <= 8) return "(-1d4)";  // Below Average
            if (score <= 12) return "(+0)";   // Average
            if (score <= 16) return "(+1d4)"; // Above Average
            if (score <= 20) return "(+2d4)"; // Strong
            // For scores above 20, add +1d4 for every 10 points (or fraction thereof) starting from 21
            // 21-29: +3d4, 30-39: +4d4, etc.
            let diceCount = 2; // Base for 17-20
            if (score > 20) {
                 diceCount = 2 + Math.ceil((score - 20) / 10);
            }
            return `(+${diceCount}d4)`;
        }


        function updateStrDamageModifiers() {
            const strScore = strInput ? strInput.value : '0'; // Add null check
            const modifierString = getStrDamageModifier(strScore);
            const modifierElements = document.querySelectorAll('.str-dmg-mod');
            modifierElements.forEach(el => {
                if (el) el.textContent = modifierString; // Add null check
            });
            // Save is triggered by the input event listener on the STR input
        }

        // --- Skill Percentage Calculation ---
        function updateSkillPercentage(rankInputElement) {
            if (!rankInputElement) return; // Add null check for input element
            const entry = rankInputElement.closest('.skill-entry');
            if (!entry) return;

            const nameSpan = entry.querySelector('.skill-name-display');
            const nameInput = entry.querySelector('.skill-name-input');
            const percentDisplay = entry.querySelector('.skill-percent-display');
            // Choose the correct element for skill details based on visibility or existence
            const detailSourceElement = (nameSpan && nameSpan.style.display !== 'none') ? nameSpan : nameInput;

            // Ensure we have a source for details and a display element
            if (!detailSourceElement || !percentDisplay) {
                console.warn("Missing detail source or percent display element in skill entry:", entry);
                return;
            }

            const rank = parseInt(rankInputElement.value) || 0;
            let basePercent = parseInt(detailSourceElement.dataset.basePercent) || 0;
            const attribute = detailSourceElement.dataset.attribute;
            const multiplier = parseInt(detailSourceElement.dataset.multiplier) || 1;

            // Calculate base percentage from attribute if applicable
            if (attribute) {
                const attrInput = document.getElementById(attribute.toLowerCase());
                if (attrInput) { // Check if attribute input exists
                    const attrValue = parseInt(attrInput.value) || 0;
                    basePercent = attrValue * multiplier;
                } else {
                     console.warn("Attribute input not found for skill:", detailSourceElement.dataset.baseSkill || detailSourceElement.value);
                }
            }

            const finalPercent = Math.min(100, basePercent + rank); // Cap at 100%
            percentDisplay.value = finalPercent; // Update the readonly display value

            // Update the text content of the span if it's visible and attribute-based
            if (attribute && nameSpan && nameSpan.style.display !== 'none') {
                 const baseSkillName = nameSpan.dataset.baseSkill || attribute;
                 const attrInput = document.getElementById(attribute.toLowerCase());
                 const attrValue = attrInput ? (parseInt(attrInput.value) || 0) : 0; // Handle missing attribute input
                 const currentBase = attrValue * multiplier;
                 nameSpan.textContent = `${baseSkillName} (${currentBase}%)`; // Show base % in brackets
            } else if (nameSpan && nameSpan.style.display !== 'none' && !attribute) {
                 // Update span text for non-attribute skills (like First Aid)
                 const baseSkillName = nameSpan.dataset.baseSkill || "Skill";
                 nameSpan.textContent = `${baseSkillName} (${basePercent}%)`;
            }

             applySkillModifiers(); // Re-apply Shift/Ctrl modifiers if active
             updateXpSpent(); // Update total XP spent
             // Save is triggered by the input event listener on the rank input
        }


        function updateDynamicSkillLabel(inputElement) {
             if (!inputElement) return; // Add null check
            // When the user types in a custom skill name, update its dataset for consistency
            // This dataset value is used as the identifier when saving/loading
            inputElement.dataset.baseSkill = inputElement.value;
            const entry = inputElement.closest('.skill-entry');
            if (entry) {
                const rankInput = entry.querySelector('.skill-rank-input');
                if (rankInput) updateSkillPercentage(rankInput); // Recalculate percentage
            }
             // Save is triggered by the input event listener on the name input
        }

        function updateAllSkillPercentages() {
            // This function is called when STR/DEX/CON changes, recalculating all skills
            document.querySelectorAll('.skill-rank-input').forEach(updateSkillPercentage);
            // Save is triggered by the input event listener on STR/DEX/CON
        }

        // --- XP Spent Calculation ---
        function updateXpSpent() {
            const xpEarnedInput = document.getElementById('char-experience');
            const xpSpentInput = document.getElementById('xp-spent');
            if (!xpEarnedInput || !xpSpentInput) return;

            let totalSpent = 0;
            // Sum ranks from all skill types
            document.querySelectorAll('.skill-entry .skill-rank-input').forEach(input => {
                if (input) totalSpent += parseInt(input.value) || 0; // Add null check
            });
            // Sum percentages from weapon skills
            document.querySelectorAll('.weapon-entry .skill-percent-input').forEach(input => {
                if (input) totalSpent += parseInt(input.value) || 0; // Add null check
            });

            xpSpentInput.value = totalSpent;
            const earned = parseInt(xpEarnedInput.value) || 0;
            // Update styling based on comparison
            xpSpentInput.classList.remove('xp-spent-over', 'xp-spent-equal', 'xp-spent-under');
            if (totalSpent > earned) xpSpentInput.classList.add('xp-spent-over');
            else if (totalSpent === earned && earned > 0) xpSpentInput.classList.add('xp-spent-equal'); // Only green if earned > 0
            else xpSpentInput.classList.add('xp-spent-under');
            // Save is triggered by the input event listener on XP Earned, skill ranks, or weapon %
        }


        function updatePercentages() {
            // Ensure characteristic inputs exist before accessing value
            const str = strInput ? parseInt(strInput.value) || 0 : 0;
            const dex = dexInput ? parseInt(dexInput.value) || 0 : 0;
            const con = conInput ? parseInt(conInput.value) || 0 : 0;

            // Ensure percent display elements exist
            if (strPercent) strPercent.value = `${Math.min(100, str * 5)}%`;
            if (dexPercent) dexPercent.value = `${Math.min(100, dex * 5)}%`;
            if (conPercent) conPercent.value = `${Math.min(100, con * 5)}%`;

            updateAllSkillPercentages(); // Recalculate all skill % based on new attributes
            updateStrDamageModifiers(); // Update weapon damage modifiers based on new STR
            applySkillModifiers(); // Re-apply shift/ctrl modifiers
            // Save is triggered by the input event listener on STR/DEX/CON
        }

        // --- Key Press Modifiers (Shift/Ctrl for temporary skill adjustments) ---
        let isShiftPressed = false;
        let isCtrlPressed = false;

        function applySkillModifiers() {
            // Apply to Skills
            document.querySelectorAll('.skill-entry').forEach(entry => {
                const percentDisplay = entry.querySelector('.skill-percent-display');
                const rankInput = entry.querySelector('.skill-rank-input');
                const nameSpan = entry.querySelector('.skill-name-display');
                const nameInput = entry.querySelector('.skill-name-input');
                // Choose the correct element for skill details based on visibility or existence
                const detailSourceElement = (nameSpan && nameSpan.style.display !== 'none') ? nameSpan : nameInput;

                // Add checks for all necessary elements
                if (!percentDisplay || !rankInput || !detailSourceElement) return;

                let basePercent = parseInt(detailSourceElement.dataset.basePercent) || 0;
                const attribute = detailSourceElement.dataset.attribute;
                const multiplier = parseInt(detailSourceElement.dataset.multiplier) || 1;
                if (attribute) {
                    const attrInput = document.getElementById(attribute.toLowerCase());
                    if (attrInput) { // Check attribute input exists
                        basePercent = (parseInt(attrInput.value) || 0) * multiplier;
                    }
                }
                const rank = parseInt(rankInput.value) || 0;
                let currentPercent = basePercent + rank; // Base calculation

                percentDisplay.classList.remove('modifier-shift', 'modifier-ctrl'); // Reset styles
                // Apply modifiers
                if (isShiftPressed) {
                    currentPercent = Math.min(100, currentPercent * 2); // Double, cap at 100
                    percentDisplay.classList.add('modifier-shift');
                } else if (isCtrlPressed) {
                    currentPercent = Math.ceil(currentPercent / 2); // Halve, round up
                    percentDisplay.classList.add('modifier-ctrl');
                }
                percentDisplay.value = Math.min(100, currentPercent); // Update display, ensure cap
            });

            // Apply to Characteristics
            ['str', 'dex', 'con'].forEach(charName => {
                const percentDisplay = document.getElementById(`${charName}-percent`);
                const charInput = document.getElementById(charName);
                // Add checks for both elements
                if (!percentDisplay || !charInput) return;

                let baseValue = parseInt(charInput.value) || 0;
                let currentPercent = Math.min(100, baseValue * 5); // Base calculation

                percentDisplay.classList.remove('modifier-shift', 'modifier-ctrl'); // Reset styles
                 // Apply modifiers
                 if (isShiftPressed) {
                    currentPercent = Math.min(100, currentPercent * 2); // Double, cap at 100
                    percentDisplay.classList.add('modifier-shift');
                } else if (isCtrlPressed) {
                    currentPercent = Math.ceil(currentPercent / 2); // Halve, round up
                    percentDisplay.classList.add('modifier-ctrl');
                }
                percentDisplay.value = `${Math.min(100, currentPercent)}%`; // Update display, ensure cap
            });
        }


        document.addEventListener('keydown', (event) => {
            // console.log(`Keydown: ${event.key}, Shift: ${event.shiftKey}, Ctrl: ${event.ctrlKey}, Active Element: ${document.activeElement.tagName}`); // DEBUGGING

            // Ignore modifier keys if focus is inside an input/textarea
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                 // console.log("Keydown ignored: Input/Textarea has focus."); // DEBUGGING
                 return;
            }

            let modifierChanged = false;
            // Check the key property directly
            if (event.key === 'Shift' && !isShiftPressed) {
                isShiftPressed = true;
                modifierChanged = true;
                // console.log("Shift pressed - applying modifiers."); // DEBUGGING
            }
            if (event.key === 'Control' && !isCtrlPressed) {
                isCtrlPressed = true;
                modifierChanged = true;
                 // console.log("Control pressed - applying modifiers."); // DEBUGGING
            }

            if (modifierChanged) {
                 // Only prevent default if a modifier key we care about was pressed
                 // event.preventDefault(); // Consider removing this if it causes issues
                 applySkillModifiers();
            }
        });

        document.addEventListener('keyup', (event) => {
             // console.log(`Keyup: ${event.key}`); // DEBUGGING

             let modifierChanged = false;
            if (event.key === 'Shift') {
                isShiftPressed = false;
                modifierChanged = true;
                // console.log("Shift released - reverting modifiers."); // DEBUGGING
            }
            if (event.key === 'Control') {
                isCtrlPressed = false;
                modifierChanged = true;
                // console.log("Control released - reverting modifiers."); // DEBUGGING
            }

             if (modifierChanged) {
                 applySkillModifiers(); // Revert to base values when key is released
             }
        });

        // Reset modifiers if the window loses focus
        window.addEventListener('blur', () => {
            // console.log("Window blurred - resetting modifiers."); // DEBUGGING
            if (isShiftPressed || isCtrlPressed) {
                isShiftPressed = false;
                isCtrlPressed = false;
                applySkillModifiers();
            }
        });

        // --- Class Change Handler ---
        function handleClassChange(selectElement) {
            const xpInput = document.getElementById('char-experience');
            if (!selectElement || !xpInput) return; // Add null checks

            const selectedClass = selectElement.value;
            // Update placeholder text based on class selection
            if (selectedClass === 'Gentleman') xpInput.placeholder = "150 (100+50 Knowledge)";
            else if (selectedClass === 'Noble') xpInput.placeholder = "200 (100+100 Knowledge)";
            else xpInput.placeholder = "100";
            // Save is triggered by the change event listener on the select element
        }

        // --- Export/Import Functions ---
        function gatherSheetData() {
            const data = { version: 3, sections: {} }; // Keep version consistent or increment if structure changes significantly

            // Helper function to safely get element value
            const getVal = (id) => document.getElementById(id)?.value || '';
            const getTextAreaVal = (selector) => document.querySelector(selector)?.value || '';
            const getSelectVal = (id) => document.getElementById(id)?.value || 'Commoner'; // Default class

            // --- Header ---
            data.header = {
                name: getVal('char-name'),
                class: getSelectVal('char-class-select'),
                profession: getVal('char-profession'),
                xpEarned: getVal('char-experience') || '0',
                goal: getVal('char-goal')
            };

            // --- Characteristics ---
            data.characteristics = {
                str: getVal('str') || '0',
                dex: getVal('dex') || '0',
                con: getVal('con') || '0'
            };

            // --- Description & Flaws ---
            data.description = {
                desc: getTextAreaVal('#char-desc'),
                flaws: getTextAreaVal('#char-flaws')
            };

            // --- Skills (Core, Knowledge, Craft/Art) ---
            data.skills = { core: [], knowledge: [], craftArt: [] };
            // --- UPDATED: Consistent saving logic for all skill types ---
            function gatherSkillData(containerId, targetArray) {
                document.querySelectorAll(`#${containerId} .skill-entry`).forEach(entry => {
                    const nameSpan = entry.querySelector('.skill-name-display');
                    const nameInput = entry.querySelector('.skill-name-input');
                    const rankInput = entry.querySelector('.skill-rank-input');

                    if (rankInput && (nameSpan || nameInput)) { // Need rank and at least one name element
                        const isUsingSpan = nameSpan && nameSpan.style.display !== 'none';
                        const detailSource = isUsingSpan ? nameSpan : nameInput;

                        if (detailSource) { // Ensure we have a valid source
                            const skillData = {
                                rank: rankInput.value || '0',
                                // Save baseSkill if span is visible (predefined), otherwise save name from input (custom)
                                baseSkill: isUsingSpan ? detailSource.dataset.baseSkill : undefined,
                                name: !isUsingSpan ? detailSource.value : undefined,
                                // Include basePercent only if it exists on the element
                                basePercent: detailSource.dataset.basePercent ? detailSource.dataset.basePercent : undefined,
                                attribute: detailSource.dataset.attribute, // Include if exists
                                multiplier: detailSource.dataset.multiplier, // Include if exists
                            };
                            // Clean up undefined properties before pushing
                            Object.keys(skillData).forEach(key => skillData[key] === undefined && delete skillData[key]);
                            targetArray.push(skillData);
                        } else {
                             console.warn("Could not find detail source (span or input) for skill in container:", containerId, entry);
                        }
                    } else {
                         console.warn("Missing rank or name element for skill in container:", containerId, entry);
                    }
                });
            }
            gatherSkillData('skills-container', data.skills.core);
            gatherSkillData('knowledge-container', data.skills.knowledge);
            gatherSkillData('craft-art-container', data.skills.craftArt); // Use same logic for Craft/Art

            // --- Combat Details (Skills, Weapons, Hit Locations) ---
            data.combat = { skills: [], meleeWeapons: [], rangedWeapons: [], hitLocations: {} };
            gatherSkillData('combat-skills-display', data.combat.skills); // Use same logic for Combat Skills

            document.querySelectorAll('#melee-weapons-container .weapon-entry').forEach(entry => {
                 data.combat.meleeWeapons.push({
                     name: entry.querySelector('textarea[placeholder="Weapon Name"]')?.value || '',
                     percent: entry.querySelector('.skill-percent-input')?.value || '0',
                     damage: entry.querySelector('.dmg-input')?.value || '',
                     notes: entry.querySelector('textarea[placeholder="Notes"]')?.value || ''
                 });
            });
             document.querySelectorAll('#ranged-weapons-container .weapon-entry').forEach(entry => {
                 data.combat.rangedWeapons.push({
                     name: entry.querySelector('textarea[placeholder="Weapon Name"]')?.value || '',
                     percent: entry.querySelector('.skill-percent-input')?.value || '0',
                     damage: entry.querySelector('.dmg-input')?.value || '', // Damage is now text
                     notes: entry.querySelector('textarea[placeholder="Notes"]')?.value || ''
                 });
            });
            // Save Hit Location AP, HP, and Item
            document.querySelectorAll('.hit-location').forEach(loc => {
                const locId = loc.dataset.loc; // e.g., "head", "l-arm"
                if (locId) {
                    data.combat.hitLocations[locId] = {
                        apCurrent: getVal(`${locId}-ap-current`) || '0',
                        apMax: getVal(`${locId}-ap-max`) || '0',
                        hpCurrent: getVal(`${locId}-hp-current`) || '0',
                        item: getVal(`${locId}-item`) || '' // Save item field
                    };
                }
            });

            // --- Inventory ---
            data.inventory = { backpack: [], satchel: '', coin: '0', dynamic: [] };
            // Save backpack slots using their IDs
            for (let i = 1; i <= 5; i++) {
                data.inventory.backpack.push(getVal(`backpack-slot-${i}`));
            }
            // Save satchel content using its ID
            data.inventory.satchel = getTextAreaVal('#satchel-items');
            data.inventory.coin = getVal('coin') || '0';
            // Save dynamic inventory sections
            document.querySelectorAll('#dynamic-inventory-container .dynamic-inventory-section').forEach(section => {
                const header = section.querySelector('.section-header');
                const dynamicSectionData = {
                    title: section.querySelector('.section-title-text')?.textContent || '',
                    color: header?.style.backgroundColor || '', // Get inline style color
                    items: []
                };
                section.querySelectorAll('.dynamic-entry input[placeholder="Item Slot"]').forEach(itemInput => {
                     dynamicSectionData.items.push({ item: itemInput.value || '' });
                });
                data.inventory.dynamic.push(dynamicSectionData);
            });

            // --- Powers ---
            data.powers = [];
             document.querySelectorAll('#powers-container .dynamic-entry input[placeholder="Power or Note"]').forEach(input => {
                 data.powers.push({ text: input.value || '' });
             });

            // --- Notes ---
            data.notes = getTextAreaVal('#notes-text');

            // --- Section Customizations (Title & Color) ---
             data.sectionCustomizations = {};
             document.querySelectorAll('.styled-section[data-section-id]').forEach(section => {
                 const sectionId = section.dataset.sectionId;
                 const titleText = section.querySelector('.section-title-text');
                 const header = section.querySelector('.section-header');
                 if (sectionId && titleText && header) {
                     const defaultTitle = section.querySelector('.section-title-input')?.getAttribute('value'); // Original title from HTML
                     const defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--default-section-bg').trim(); // Default CSS variable color
                     const currentTitle = titleText.textContent;
                     const currentColor = header.style.backgroundColor; // Current inline style color

                     let customization = {};
                     let hasCustomization = false;
                     // Save title only if it's different from the default HTML value
                     if (defaultTitle && currentTitle !== defaultTitle) {
                          customization.title = currentTitle;
                          hasCustomization = true;
                     }
                     // Save color only if it has an inline style set AND it's different from the CSS variable default
                     // Check for rgb format which might be returned by computed style vs hex/named color set inline
                     const isColorSetAndDifferent = currentColor && currentColor !== defaultColor && header.style.backgroundColor !== '';
                     if (isColorSetAndDifferent) {
                          customization.color = currentColor;
                          hasCustomization = true;
                     }
                     // Only add to customizations if title or color was actually changed
                     if (hasCustomization) {
                         data.sectionCustomizations[sectionId] = customization;
                     }
                 }
             });

            return data;
        }


        function exportSheetData() {
            try {
                const sheetData = gatherSheetData();
                const jsonData = JSON.stringify(sheetData, null, 2); // Pretty print JSON
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const charName = document.getElementById('char-name')?.value || 'character';
                const filename = `${charName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_winedark_sheet.json`; // Sanitize filename
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click(); // Trigger download
                document.body.removeChild(link); // Clean up link
                URL.revokeObjectURL(url); // Release object URL
                showDicePopup("Sheet data exported successfully!");
            } catch (error) {
                console.error("Error exporting sheet data:", error);
                showDicePopup("Error exporting sheet data. See console.");
            }
        }

        function importSheetData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = e.target.result;
                    const data = JSON.parse(jsonData);
                    // Basic validation
                    if (typeof data !== 'object' || data === null || !data.version) {
                         throw new Error("Invalid file format or missing version.");
                    }
                    // Optional: Add more specific version checking if needed
                    // if (data.version < 3) {
                    //     throw new Error("Outdated file version. Please update the sheet first.");
                    // }
                    console.log("Importing data version:", data.version); // DEBUGGING

                    // --- IMPORTANT: Reset sheet state *before* populating ---
                    setDefaultSheetState(false); // Reset without recalc
                    populateSheetData(data); // Populate DOM from imported data

                    // Recalculate everything *after* populating
                    updateHpDisplay();
                    updatePercentages();
                    updateXpSpent();

                    saveSheetToLocalStorage(); // Save the newly imported data to local storage
                    showDicePopup("Sheet data imported successfully!");
                } catch (error) {
                    console.error("Error importing sheet data:", error); // DEBUGGING
                    showDicePopup(`Error importing file: ${error.message}. See console.`);
                } finally {
                     event.target.value = null; // Reset file input to allow importing the same file again
                }
            };
            reader.onerror = function(e) {
                 console.error("Error reading file:", e);
                 showDicePopup("Error reading file.");
                 event.target.value = null;
            };
            reader.readAsText(file);
        }

       function populateSheetData(data) {
            // console.log("Populating sheet data from saved/imported source..."); // DEBUGGING
            // Helper to safely set value
            const setVal = (id, value) => {
                const el = document.getElementById(id);
                if (el) {
                    el.value = value;
                    // Mark HP inputs as loaded to prevent reset in updateHpDisplay
                    if (el.classList.contains('hp-current')) {
                        el.dataset.loaded = 'true';
                    }
                }
                else console.warn(`Element not found for setting value: ${id}`);
            };
            const setTextAreaVal = (selector, value) => {
                const el = document.querySelector(selector);
                if (el) {
                     el.value = value;
                     autoExpandTextarea(el); // Auto expand after setting value
                } else console.warn(`Element not found for setting textarea value: ${selector}`);
            };
            const setSelectVal = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.value = value;
                else console.warn(`Element not found for setting select value: ${id}`);
            };

            // --- Populate Header ---
            if (data.header) {
                setVal('char-name', data.header.name);
                setSelectVal('char-class-select', data.header.class || 'Commoner');
                handleClassChange(document.getElementById('char-class-select')); // Update placeholder based on class
                setVal('char-profession', data.header.profession);
                setVal('char-experience', data.header.xpEarned || '0');
                setVal('char-goal', data.header.goal);
            }

            // --- Populate Characteristics ---
            if (data.characteristics) {
                setVal('str', data.characteristics.str || '0');
                setVal('dex', data.characteristics.dex || '0');
                setVal('con', data.characteristics.con || '0');
            }

            // --- Populate Description & Flaws ---
            if (data.description) {
                setTextAreaVal('#char-desc', data.description.desc);
                setTextAreaVal('#char-flaws', data.description.flaws);
            }

            // --- Populate Skills (Rebuild from saved data) ---
            // Assumes setDefaultSheetState(false) has already cleared the containers
            if (data.skills) {
                data.skills.core?.forEach(skillData => addEntry('skills-container', skillTemplate, skillData));
                data.skills.knowledge?.forEach(skillData => addEntry('knowledge-container', knowledgeTemplate, skillData));
                // --- UPDATED: Craft/Art uses consistent addEntry logic now ---
                data.skills.craftArt?.forEach(skillData => addEntry('craft-art-container', craftArtTemplate, skillData));
            }

            // --- Populate Combat Details (Skills, Weapons & Hit Locations) ---
            if (data.combat) {
                // Combat Skills (Rebuild from saved data)
                data.combat.skills?.forEach(skillData => addEntry('combat-skills-display', combatStatTemplate, skillData));

                // Weapons (Rebuild from saved data)
                data.combat.meleeWeapons?.forEach(weaponData => addEntry('melee-weapons-container', meleeWeaponTemplate, weaponData));
                data.combat.rangedWeapons?.forEach(weaponData => addEntry('ranged-weapons-container', rangedWeaponTemplate, weaponData));

                // Load Hit Location AP, HP, and Item
                if (data.combat.hitLocations) {
                    Object.keys(data.combat.hitLocations).forEach(locId => {
                        const locData = data.combat.hitLocations[locId];
                        if (locData) {
                            setVal(`${locId}-ap-current`, locData.apCurrent || '0');
                            setVal(`${locId}-ap-max`, locData.apMax || '0');
                            setVal(`${locId}-hp-current`, locData.hpCurrent || '0');
                            setVal(`${locId}-item`, locData.item || ''); // Load item field
                        }
                    });
                }
            }

            // --- Populate Inventory ---
            if (data.inventory) {
                // Backpack (Update existing inputs using their IDs)
                data.inventory.backpack?.forEach((item, index) => {
                    setVal(`backpack-slot-${index + 1}`, item || ''); // index is 0-based, IDs are 1-based
                });
                // Satchel & Coin (Update using IDs)
                setTextAreaVal('#satchel-items', data.inventory.satchel);
                setVal('coin', data.inventory.coin || '0');
                // Dynamic Containers (Rebuild from saved data)
                data.inventory.dynamic?.forEach(sectionData => addInventorySection(sectionData));
            }

            // --- Populate Powers (Rebuild from saved data) ---
            data.powers?.forEach(powerData => addEntry('powers-container', powerTemplate, powerData));

            // --- Populate Notes ---
            setTextAreaVal('#notes-text', data.notes);

            // --- Populate Section Customizations (Titles & Colors) ---
            if (data.sectionCustomizations) {
                Object.keys(data.sectionCustomizations).forEach(sectionId => {
                    const section = document.querySelector(`.styled-section[data-section-id="${sectionId}"]`);
                    const customData = data.sectionCustomizations[sectionId];
                    if (section && customData) {
                        const titleText = section.querySelector('.section-title-text');
                        const titleInput = section.querySelector('.section-title-input'); // For setting value if needed
                        const header = section.querySelector('.section-header');
                        const colorInput = section.querySelector('.color-picker-input'); // The actual <input type="color">

                        // Apply title customization
                        if (titleText && customData.title) {
                             titleText.textContent = customData.title;
                             // Also update the hidden input's value for consistency if editing is toggled
                             if (titleInput) titleInput.value = customData.title;
                        }
                        // Apply color customization
                        if (header && customData.color) {
                             header.style.backgroundColor = customData.color; // Apply to header background
                             // Also update the color picker's value
                             if (colorInput) colorInput.value = customData.color;
                        }
                    }
                });
            }

            // --- Clear loaded flags after population ---
            document.querySelectorAll('.hp-current').forEach(el => el.removeAttribute('data-loaded'));

            // console.log("Finished populating sheet data."); // DEBUGGING
        }


        // --- Reset Character Sheet Function ---
        function resetCharacterSheet() {
            const confirmed = confirm("Warning: Creating a new character will delete the current one from this browser. Export your character first if you want to save it permanently. Continue?");
            if (confirmed) {
                localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear saved data
                setDefaultSheetState(true); // Reset to defaults and recalculate
                showDicePopup("Character sheet reset.");
            }
        }

        // --- Set Default Sheet State ---
        function setDefaultSheetState(updateCalculations = true) {
            // console.log("Setting default sheet state..."); // DEBUGGING

            // --- Clear Dynamic Content Containers ---
            const containersToClear = [
                'skills-container', 'knowledge-container', 'craft-art-container', // Skills
                'combat-skills-display', 'melee-weapons-container', 'ranged-weapons-container', // Combat
                'powers-container', // Powers
                'dynamic-inventory-container', // Dynamic Inventory Sections
                'dynamic-stats-container' // Placeholder if used
            ];
            containersToClear.forEach(id => {
                const container = document.getElementById(id);
                if (container) {
                    container.innerHTML = ''; // Clear the container
                } else {
                    console.warn(`Container ID not found during reset: ${id}`);
                }
            });

            // --- Reset Header fields ---
            const fieldsToReset = ['char-name', 'char-profession', 'char-goal'];
            fieldsToReset.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.value = '';
            });
            const numsToReset = {'char-experience': '0', 'coin': '10'}; // Default values
            Object.keys(numsToReset).forEach(id => {
                 const el = document.getElementById(id);
                 if (el) el.value = numsToReset[id];
            });
            const classSelect = document.getElementById('char-class-select');
            if (classSelect) {
                 classSelect.value = 'Commoner'; // Default class
                 handleClassChange(classSelect); // Update placeholder
            }

            // --- Reset Characteristics ---
            const charsToReset = {'str': '0', 'dex': '0', 'con': '0'};
             Object.keys(charsToReset).forEach(id => {
                 const el = document.getElementById(id);
                 if (el) el.value = charsToReset[id];
            });

            // --- Reset Description & Flaws & Notes ---
            const textAreasToReset = ['#char-desc', '#char-flaws', '#notes-text', '#satchel-items'];
            textAreasToReset.forEach(selector => {
                 const el = document.querySelector(selector);
                 if (el) {
                     el.value = '';
                     autoExpandTextarea(el); // Reset height
                 }
            });

            // --- Reset Static Inventory (Backpack/Satchel) ---
             for (let i = 1; i <= 5; i++) {
                const slot = document.getElementById(`backpack-slot-${i}`);
                if (slot) slot.value = '';
             }
             // Satchel reset is handled above with other textareas


            // --- Populate Default Skills (Core, Knowledge, Combat, Craft/Art) ---
            if (updateCalculations) { // Only add defaults if we are doing a full reset (not just clearing for load)
                defaultSheetStructure.skills.core.forEach(skillDef => addEntry('skills-container', skillTemplate, { ...skillDef, rank: '0' }));
                defaultSheetStructure.skills.knowledge.forEach(skillDef => addEntry('knowledge-container', knowledgeTemplate, { ...skillDef, rank: '0' }));
                defaultSheetStructure.combat.skills.forEach(skillDef => addEntry('combat-skills-display', combatStatTemplate, { ...skillDef, rank: '0' }));
                // --- UPDATED: Add default craft/art using consistent logic ---
                defaultSheetStructure.skills.craftArt.forEach(skillDef => addEntry('craft-art-container', craftArtTemplate, skillDef));
            }


            // --- Reset Hit Locations (AP/HP/Item) ---
            document.querySelectorAll('.hit-location').forEach(loc => {
                const locId = loc.dataset.loc;
                if (locId) {
                    const apCurrent = document.getElementById(`${locId}-ap-current`);
                    const apMax = document.getElementById(`${locId}-ap-max`);
                    const hpCurrent = document.getElementById(`${locId}-hp-current`);
                    const itemInput = document.getElementById(`${locId}-item`);
                    const hpMaxSpan = loc.querySelector('.hp-max');

                    if(apCurrent) apCurrent.value = '0';
                    if(apMax) apMax.value = '0';
                    if(hpCurrent) hpCurrent.value = '0';
                    if(itemInput) itemInput.value = ''; // Clear item input
                    if(hpMaxSpan) hpMaxSpan.textContent = '0';
                }
            });

            // --- Reset Section Customizations (Titles & Colors) ---
            const defaultColor = getComputedStyle(document.documentElement).getPropertyValue('--default-section-bg').trim();
            document.querySelectorAll('.styled-section[data-section-id]').forEach(section => {
                 const titleText = section.querySelector('.section-title-text');
                 const titleInput = section.querySelector('.section-title-input');
                 const header = section.querySelector('.section-header');
                 const colorInput = section.querySelector('.color-picker-input');
                 const defaultTitle = titleInput?.getAttribute('value'); // Get original title from HTML attribute

                 // Reset title
                 if (titleText && defaultTitle) titleText.textContent = defaultTitle;
                 if (titleInput && defaultTitle) titleInput.value = defaultTitle; // Reset hidden input too
                 // Reset color
                 if (header) header.style.backgroundColor = ''; // Remove inline style to revert to CSS default
                 if (colorInput) { // Reset color picker value (convert default if needed)
                    try {
                        // Attempt direct assignment, works if defaultColor is hex/named
                        colorInput.value = defaultColor;
                    } catch (e) {
                        // Fallback if defaultColor is rgb() or similar - set to black
                        console.warn("Could not set default color picker value, using black fallback.", defaultColor, e);
                        colorInput.value = '#000000';
                    }
                 }
            });

            // --- Recalculate derived values if requested ---
            if (updateCalculations) {
                // console.log("Recalculating after setting default state..."); // DEBUGGING
                updateHpDisplay(); // Recalculate HP based on default CON(0)
                updatePercentages(); // Recalculate percentages based on default STR/DEX/CON(0) and default skill ranks(0)
                updateXpSpent(); // Recalculate XP spent (should be 0)
                 // console.log("Recalculations complete after default state."); // DEBUGGING
            }
             // No save needed here, as this is usually followed by loading or is a manual reset
             // console.log("Finished setting default state."); // DEBUGGING
        }


        // --- Initial Setup on Page Load ---
        document.addEventListener('DOMContentLoaded', () => {
            // console.log("DOM Content Loaded. Initializing sheet..."); // DEBUGGING

            // Attempt to load saved data. If successful, it populates and calculates.
            // If it fails or no data exists, it calls setDefaultSheetState(true) to set defaults and calculate.
            loadSheetFromLocalStorage();

            // Add event listener to the main container for inputs/changes to trigger debounced save
            const sheetContainer = document.getElementById('character-sheet-container');
            if (sheetContainer) {
                // Use event delegation for better performance
                sheetContainer.addEventListener('input', (event) => {
                    // Trigger save for relevant input types
                    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName)) {
                        // console.log('Input event triggered save for:', event.target.id || event.target.placeholder); // DEBUGGING
                        debouncedSave();
                    }
                    // Auto-expand textareas on input
                    if (event.target.tagName === 'TEXTAREA' && event.target.classList.contains('auto-expand')) {
                        autoExpandTextarea(event.target);
                    }
                });
                 // Listen for changes specifically on color pickers and select dropdowns
                 sheetContainer.addEventListener('change', (event) => {
                     if (event.target.type === 'color' || event.target.tagName === 'SELECT') {
                        // console.log('Change event triggered save for:', event.target.id || event.target.tagName); // DEBUGGING
                         debouncedSave();
                     }
                 });
            } else {
                console.error("Character sheet container not found!");
            }


            // Initialize auto-expand for any existing textareas (important after loading data)
            document.querySelectorAll('textarea.auto-expand').forEach(autoExpandTextarea);

             // Add click listener to dice popup to close it
             if(dicePopup) {
                 dicePopup.addEventListener('click', closeDicePopup);
             }

            // console.log("Sheet initialization complete."); // DEBUGGING
        });

    </script>

</body>
</html>

